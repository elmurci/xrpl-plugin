// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/ripple/proto/ripple.proto

#include "src/ripple/proto/ripple.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace protocol {
PROTOBUF_CONSTEXPR TMManifest::TMManifest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stobject_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TMManifestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMManifestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMManifestDefaultTypeInternal() {}
  union {
    TMManifest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMManifestDefaultTypeInternal _TMManifest_default_instance_;
PROTOBUF_CONSTEXPR TMManifests::TMManifests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.list_)*/{}
  , /*decltype(_impl_.history_)*/false} {}
struct TMManifestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMManifestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMManifestsDefaultTypeInternal() {}
  union {
    TMManifests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMManifestsDefaultTypeInternal _TMManifests_default_instance_;
PROTOBUF_CONSTEXPR TMClusterNode::TMClusterNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reporttime_)*/0u
  , /*decltype(_impl_.nodeload_)*/0u} {}
struct TMClusterNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMClusterNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMClusterNodeDefaultTypeInternal() {}
  union {
    TMClusterNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMClusterNodeDefaultTypeInternal _TMClusterNode_default_instance_;
PROTOBUF_CONSTEXPR TMLoadSource::TMLoadSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cost_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct TMLoadSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMLoadSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMLoadSourceDefaultTypeInternal() {}
  union {
    TMLoadSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMLoadSourceDefaultTypeInternal _TMLoadSource_default_instance_;
PROTOBUF_CONSTEXPR TMCluster::TMCluster(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clusternodes_)*/{}
  , /*decltype(_impl_.loadsources_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TMClusterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMClusterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMClusterDefaultTypeInternal() {}
  union {
    TMCluster _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMClusterDefaultTypeInternal _TMCluster_default_instance_;
PROTOBUF_CONSTEXPR TMLink::TMLink(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodepubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TMLinkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMLinkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMLinkDefaultTypeInternal() {}
  union {
    TMLink _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMLinkDefaultTypeInternal _TMLink_default_instance_;
PROTOBUF_CONSTEXPR TMGetPeerShardInfo::TMGetPeerShardInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.peerchain_)*/{}
  , /*decltype(_impl_.hops_)*/0u
  , /*decltype(_impl_.lastlink_)*/false} {}
struct TMGetPeerShardInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMGetPeerShardInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMGetPeerShardInfoDefaultTypeInternal() {}
  union {
    TMGetPeerShardInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMGetPeerShardInfoDefaultTypeInternal _TMGetPeerShardInfo_default_instance_;
PROTOBUF_CONSTEXPR TMPeerShardInfo::TMPeerShardInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.peerchain_)*/{}
  , /*decltype(_impl_.shardindexes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodepubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.endpoint_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lastlink_)*/false} {}
struct TMPeerShardInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMPeerShardInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMPeerShardInfoDefaultTypeInternal() {}
  union {
    TMPeerShardInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMPeerShardInfoDefaultTypeInternal _TMPeerShardInfo_default_instance_;
PROTOBUF_CONSTEXPR TMPublicKey::TMPublicKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TMPublicKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMPublicKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMPublicKeyDefaultTypeInternal() {}
  union {
    TMPublicKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMPublicKeyDefaultTypeInternal _TMPublicKey_default_instance_;
PROTOBUF_CONSTEXPR TMGetPeerShardInfoV2::TMGetPeerShardInfoV2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.peerchain_)*/{}
  , /*decltype(_impl_.relays_)*/0u} {}
struct TMGetPeerShardInfoV2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMGetPeerShardInfoV2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMGetPeerShardInfoV2DefaultTypeInternal() {}
  union {
    TMGetPeerShardInfoV2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMGetPeerShardInfoV2DefaultTypeInternal _TMGetPeerShardInfoV2_default_instance_;
PROTOBUF_CONSTEXPR TMPeerShardInfoV2_TMIncomplete::TMPeerShardInfoV2_TMIncomplete(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shardindex_)*/0u
  , /*decltype(_impl_.state_)*/0u
  , /*decltype(_impl_.progress_)*/0u} {}
struct TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal() {}
  union {
    TMPeerShardInfoV2_TMIncomplete _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal _TMPeerShardInfoV2_TMIncomplete_default_instance_;
PROTOBUF_CONSTEXPR TMPeerShardInfoV2::TMPeerShardInfoV2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.incomplete_)*/{}
  , /*decltype(_impl_.peerchain_)*/{}
  , /*decltype(_impl_.finalized_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.publickey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/0u} {}
struct TMPeerShardInfoV2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMPeerShardInfoV2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMPeerShardInfoV2DefaultTypeInternal() {}
  union {
    TMPeerShardInfoV2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMPeerShardInfoV2DefaultTypeInternal _TMPeerShardInfoV2_default_instance_;
PROTOBUF_CONSTEXPR TMTransaction::TMTransaction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rawtransaction_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.receivetimestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.deferred_)*/false
  , /*decltype(_impl_.status_)*/1} {}
struct TMTransactionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMTransactionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMTransactionDefaultTypeInternal() {}
  union {
    TMTransaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMTransactionDefaultTypeInternal _TMTransaction_default_instance_;
PROTOBUF_CONSTEXPR TMTransactions::TMTransactions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TMTransactionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMTransactionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMTransactionsDefaultTypeInternal() {}
  union {
    TMTransactions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMTransactionsDefaultTypeInternal _TMTransactions_default_instance_;
PROTOBUF_CONSTEXPR TMStatusChange::TMStatusChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerhashprevious_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerseq_)*/0u
  , /*decltype(_impl_.firstseq_)*/0u
  , /*decltype(_impl_.networktime_)*/uint64_t{0u}
  , /*decltype(_impl_.lastseq_)*/0u
  , /*decltype(_impl_.newstatus_)*/1
  , /*decltype(_impl_.newevent_)*/1} {}
struct TMStatusChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMStatusChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMStatusChangeDefaultTypeInternal() {}
  union {
    TMStatusChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMStatusChangeDefaultTypeInternal _TMStatusChange_default_instance_;
PROTOBUF_CONSTEXPR TMProposeSet::TMProposeSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.addedtransactions_)*/{}
  , /*decltype(_impl_.removedtransactions_)*/{}
  , /*decltype(_impl_.currenttxhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodepubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.previousledger_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.proposeseq_)*/0u
  , /*decltype(_impl_.closetime_)*/0u
  , /*decltype(_impl_.checkedsignature_)*/false
  , /*decltype(_impl_.hops_)*/0u
  , /*decltype(_impl_.ledgerseq_)*/0u} {}
struct TMProposeSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMProposeSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMProposeSetDefaultTypeInternal() {}
  union {
    TMProposeSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMProposeSetDefaultTypeInternal _TMProposeSet_default_instance_;
PROTOBUF_CONSTEXPR TMHaveTransactionSet::TMHaveTransactionSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/1} {}
struct TMHaveTransactionSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMHaveTransactionSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMHaveTransactionSetDefaultTypeInternal() {}
  union {
    TMHaveTransactionSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMHaveTransactionSetDefaultTypeInternal _TMHaveTransactionSet_default_instance_;
PROTOBUF_CONSTEXPR TMValidatorList::TMValidatorList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.manifest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.blob_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0u} {}
struct TMValidatorListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMValidatorListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMValidatorListDefaultTypeInternal() {}
  union {
    TMValidatorList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMValidatorListDefaultTypeInternal _TMValidatorList_default_instance_;
PROTOBUF_CONSTEXPR ValidatorBlobInfo::ValidatorBlobInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.manifest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.blob_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ValidatorBlobInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValidatorBlobInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValidatorBlobInfoDefaultTypeInternal() {}
  union {
    ValidatorBlobInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValidatorBlobInfoDefaultTypeInternal _ValidatorBlobInfo_default_instance_;
PROTOBUF_CONSTEXPR TMValidatorListCollection::TMValidatorListCollection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.blobs_)*/{}
  , /*decltype(_impl_.manifest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0u} {}
struct TMValidatorListCollectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMValidatorListCollectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMValidatorListCollectionDefaultTypeInternal() {}
  union {
    TMValidatorListCollection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMValidatorListCollectionDefaultTypeInternal _TMValidatorListCollection_default_instance_;
PROTOBUF_CONSTEXPR TMValidation::TMValidation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.validation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.checkedsignature_)*/false
  , /*decltype(_impl_.hops_)*/0u} {}
struct TMValidationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMValidationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMValidationDefaultTypeInternal() {}
  union {
    TMValidation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMValidationDefaultTypeInternal _TMValidation_default_instance_;
PROTOBUF_CONSTEXPR TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.endpoint_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hops_)*/0u} {}
struct TMEndpoints_TMEndpointv2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMEndpoints_TMEndpointv2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMEndpoints_TMEndpointv2DefaultTypeInternal() {}
  union {
    TMEndpoints_TMEndpointv2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMEndpoints_TMEndpointv2DefaultTypeInternal _TMEndpoints_TMEndpointv2_default_instance_;
PROTOBUF_CONSTEXPR TMEndpoints::TMEndpoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.endpoints_v2_)*/{}
  , /*decltype(_impl_.version_)*/0u} {}
struct TMEndpointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMEndpointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMEndpointsDefaultTypeInternal() {}
  union {
    TMEndpoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMEndpointsDefaultTypeInternal _TMEndpoints_default_instance_;
PROTOBUF_CONSTEXPR TMIndexedObject::TMIndexedObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.index_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerseq_)*/0u} {}
struct TMIndexedObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMIndexedObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMIndexedObjectDefaultTypeInternal() {}
  union {
    TMIndexedObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMIndexedObjectDefaultTypeInternal _TMIndexedObject_default_instance_;
PROTOBUF_CONSTEXPR TMGetObjectByHash::TMGetObjectByHash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.seq_)*/0u
  , /*decltype(_impl_.query_)*/false
  , /*decltype(_impl_.fat_)*/false} {}
struct TMGetObjectByHashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMGetObjectByHashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMGetObjectByHashDefaultTypeInternal() {}
  union {
    TMGetObjectByHash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMGetObjectByHashDefaultTypeInternal _TMGetObjectByHash_default_instance_;
PROTOBUF_CONSTEXPR TMLedgerNode::TMLedgerNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodedata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TMLedgerNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMLedgerNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMLedgerNodeDefaultTypeInternal() {}
  union {
    TMLedgerNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMLedgerNodeDefaultTypeInternal _TMLedgerNode_default_instance_;
PROTOBUF_CONSTEXPR TMGetLedger::TMGetLedger(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodeids_)*/{}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.itype_)*/0
  , /*decltype(_impl_.ltype_)*/0
  , /*decltype(_impl_.ledgerseq_)*/0u
  , /*decltype(_impl_.querytype_)*/0
  , /*decltype(_impl_.requestcookie_)*/uint64_t{0u}
  , /*decltype(_impl_.querydepth_)*/0u} {}
struct TMGetLedgerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMGetLedgerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMGetLedgerDefaultTypeInternal() {}
  union {
    TMGetLedger _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMGetLedgerDefaultTypeInternal _TMGetLedger_default_instance_;
PROTOBUF_CONSTEXPR TMLedgerData::TMLedgerData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerseq_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.requestcookie_)*/0u
  , /*decltype(_impl_.error_)*/1} {}
struct TMLedgerDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMLedgerDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMLedgerDataDefaultTypeInternal() {}
  union {
    TMLedgerData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMLedgerDataDefaultTypeInternal _TMLedgerData_default_instance_;
PROTOBUF_CONSTEXPR TMPing::TMPing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.seq_)*/0u
  , /*decltype(_impl_.pingtime_)*/uint64_t{0u}
  , /*decltype(_impl_.nettime_)*/uint64_t{0u}} {}
struct TMPingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMPingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMPingDefaultTypeInternal() {}
  union {
    TMPing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMPingDefaultTypeInternal _TMPing_default_instance_;
PROTOBUF_CONSTEXPR TMSquelch::TMSquelch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.validatorpubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.squelch_)*/false
  , /*decltype(_impl_.squelchduration_)*/0u} {}
struct TMSquelchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMSquelchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMSquelchDefaultTypeInternal() {}
  union {
    TMSquelch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMSquelchDefaultTypeInternal _TMSquelch_default_instance_;
PROTOBUF_CONSTEXPR TMProofPathRequest::TMProofPathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/1} {}
struct TMProofPathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMProofPathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMProofPathRequestDefaultTypeInternal() {}
  union {
    TMProofPathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMProofPathRequestDefaultTypeInternal _TMProofPathRequest_default_instance_;
PROTOBUF_CONSTEXPR TMProofPathResponse::TMProofPathResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerheader_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/1
  , /*decltype(_impl_.error_)*/1} {}
struct TMProofPathResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMProofPathResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMProofPathResponseDefaultTypeInternal() {}
  union {
    TMProofPathResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMProofPathResponseDefaultTypeInternal _TMProofPathResponse_default_instance_;
PROTOBUF_CONSTEXPR TMReplayDeltaRequest::TMReplayDeltaRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TMReplayDeltaRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMReplayDeltaRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMReplayDeltaRequestDefaultTypeInternal() {}
  union {
    TMReplayDeltaRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMReplayDeltaRequestDefaultTypeInternal _TMReplayDeltaRequest_default_instance_;
PROTOBUF_CONSTEXPR TMReplayDeltaResponse::TMReplayDeltaResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transaction_)*/{}
  , /*decltype(_impl_.ledgerhash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledgerheader_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/1} {}
struct TMReplayDeltaResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMReplayDeltaResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMReplayDeltaResponseDefaultTypeInternal() {}
  union {
    TMReplayDeltaResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMReplayDeltaResponseDefaultTypeInternal _TMReplayDeltaResponse_default_instance_;
PROTOBUF_CONSTEXPR TMHaveTransactions::TMHaveTransactions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hashes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TMHaveTransactionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMHaveTransactionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMHaveTransactionsDefaultTypeInternal() {}
  union {
    TMHaveTransactions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMHaveTransactionsDefaultTypeInternal _TMHaveTransactions_default_instance_;
}  // namespace protocol
static ::_pb::Metadata file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[35];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_src_2fripple_2fproto_2fripple_2eproto = nullptr;

const uint32_t TableStruct_src_2fripple_2fproto_2fripple_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _impl_.stobject_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _impl_.list_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _impl_.history_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _impl_.publickey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _impl_.reporttime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _impl_.nodeload_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _impl_.nodename_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _impl_.address_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _impl_.cost_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _impl_.count_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _impl_.clusternodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _impl_.loadsources_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _impl_.nodepubkey_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _impl_.hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _impl_.lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _impl_.peerchain_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _impl_.shardindexes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _impl_.nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _impl_.endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _impl_.lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _impl_.peerchain_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPublicKey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPublicKey, _impl_.publickey_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, _impl_.peerchain_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, _impl_.relays_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _impl_.shardindex_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _impl_.progress_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_.incomplete_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_.finalized_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_.publickey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _impl_.peerchain_),
  3,
  ~0u,
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _impl_.rawtransaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _impl_.receivetimestamp_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _impl_.deferred_),
  0,
  3,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransactions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransactions, _impl_.transactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.newstatus_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.newevent_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.ledgerhashprevious_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.networktime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.firstseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _impl_.lastseq_),
  6,
  7,
  2,
  0,
  1,
  4,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.proposeseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.currenttxhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.closetime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.previousledger_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.addedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.removedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _impl_.ledgerseq_),
  4,
  0,
  1,
  5,
  2,
  3,
  ~0u,
  ~0u,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _impl_.hash_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _impl_.manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _impl_.blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _impl_.version_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _impl_.manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _impl_.blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _impl_.signature_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _impl_.manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _impl_.blobs_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _impl_.validation_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _impl_.checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _impl_.hops_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _impl_.endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _impl_.hops_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _impl_.endpoints_v2_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _impl_.nodeid_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _impl_.ledgerseq_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_.query_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_.seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_.fat_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _impl_.objects_),
  1,
  3,
  2,
  0,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _impl_.nodedata_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _impl_.nodeid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.itype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.ltype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.nodeids_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.querytype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _impl_.querydepth_),
  1,
  2,
  0,
  3,
  ~0u,
  5,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_.ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_.requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _impl_.error_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _impl_.seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _impl_.pingtime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _impl_.nettime_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _impl_.squelch_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _impl_.validatorpubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _impl_.squelchduration_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _impl_.type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_.ledgerheader_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _impl_.error_),
  0,
  1,
  3,
  2,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _impl_.ledgerhash_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _impl_.ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _impl_.ledgerheader_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _impl_.transaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _impl_.error_),
  0,
  1,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactions, _impl_.hashes_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::protocol::TMManifest)},
  { 8, 16, -1, sizeof(::protocol::TMManifests)},
  { 18, 29, -1, sizeof(::protocol::TMClusterNode)},
  { 34, 43, -1, sizeof(::protocol::TMLoadSource)},
  { 46, -1, -1, sizeof(::protocol::TMCluster)},
  { 54, 61, -1, sizeof(::protocol::TMLink)},
  { 62, 71, -1, sizeof(::protocol::TMGetPeerShardInfo)},
  { 74, 85, -1, sizeof(::protocol::TMPeerShardInfo)},
  { 90, 97, -1, sizeof(::protocol::TMPublicKey)},
  { 98, 106, -1, sizeof(::protocol::TMGetPeerShardInfoV2)},
  { 108, 117, -1, sizeof(::protocol::TMPeerShardInfoV2_TMIncomplete)},
  { 120, 132, -1, sizeof(::protocol::TMPeerShardInfoV2)},
  { 138, 148, -1, sizeof(::protocol::TMTransaction)},
  { 152, -1, -1, sizeof(::protocol::TMTransactions)},
  { 159, 173, -1, sizeof(::protocol::TMStatusChange)},
  { 181, 198, -1, sizeof(::protocol::TMProposeSet)},
  { 209, 217, -1, sizeof(::protocol::TMHaveTransactionSet)},
  { 219, 229, -1, sizeof(::protocol::TMValidatorList)},
  { 233, 242, -1, sizeof(::protocol::ValidatorBlobInfo)},
  { 245, 254, -1, sizeof(::protocol::TMValidatorListCollection)},
  { 257, 266, -1, sizeof(::protocol::TMValidation)},
  { 269, 277, -1, sizeof(::protocol::TMEndpoints_TMEndpointv2)},
  { 279, 287, -1, sizeof(::protocol::TMEndpoints)},
  { 289, 300, -1, sizeof(::protocol::TMIndexedObject)},
  { 305, 317, -1, sizeof(::protocol::TMGetObjectByHash)},
  { 323, 331, -1, sizeof(::protocol::TMLedgerNode)},
  { 333, 347, -1, sizeof(::protocol::TMGetLedger)},
  { 355, 367, -1, sizeof(::protocol::TMLedgerData)},
  { 373, 383, -1, sizeof(::protocol::TMPing)},
  { 387, 396, -1, sizeof(::protocol::TMSquelch)},
  { 399, 408, -1, sizeof(::protocol::TMProofPathRequest)},
  { 411, 423, -1, sizeof(::protocol::TMProofPathResponse)},
  { 429, 436, -1, sizeof(::protocol::TMReplayDeltaRequest)},
  { 437, 447, -1, sizeof(::protocol::TMReplayDeltaResponse)},
  { 451, -1, -1, sizeof(::protocol::TMHaveTransactions)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::protocol::_TMManifest_default_instance_._instance,
  &::protocol::_TMManifests_default_instance_._instance,
  &::protocol::_TMClusterNode_default_instance_._instance,
  &::protocol::_TMLoadSource_default_instance_._instance,
  &::protocol::_TMCluster_default_instance_._instance,
  &::protocol::_TMLink_default_instance_._instance,
  &::protocol::_TMGetPeerShardInfo_default_instance_._instance,
  &::protocol::_TMPeerShardInfo_default_instance_._instance,
  &::protocol::_TMPublicKey_default_instance_._instance,
  &::protocol::_TMGetPeerShardInfoV2_default_instance_._instance,
  &::protocol::_TMPeerShardInfoV2_TMIncomplete_default_instance_._instance,
  &::protocol::_TMPeerShardInfoV2_default_instance_._instance,
  &::protocol::_TMTransaction_default_instance_._instance,
  &::protocol::_TMTransactions_default_instance_._instance,
  &::protocol::_TMStatusChange_default_instance_._instance,
  &::protocol::_TMProposeSet_default_instance_._instance,
  &::protocol::_TMHaveTransactionSet_default_instance_._instance,
  &::protocol::_TMValidatorList_default_instance_._instance,
  &::protocol::_ValidatorBlobInfo_default_instance_._instance,
  &::protocol::_TMValidatorListCollection_default_instance_._instance,
  &::protocol::_TMValidation_default_instance_._instance,
  &::protocol::_TMEndpoints_TMEndpointv2_default_instance_._instance,
  &::protocol::_TMEndpoints_default_instance_._instance,
  &::protocol::_TMIndexedObject_default_instance_._instance,
  &::protocol::_TMGetObjectByHash_default_instance_._instance,
  &::protocol::_TMLedgerNode_default_instance_._instance,
  &::protocol::_TMGetLedger_default_instance_._instance,
  &::protocol::_TMLedgerData_default_instance_._instance,
  &::protocol::_TMPing_default_instance_._instance,
  &::protocol::_TMSquelch_default_instance_._instance,
  &::protocol::_TMProofPathRequest_default_instance_._instance,
  &::protocol::_TMProofPathResponse_default_instance_._instance,
  &::protocol::_TMReplayDeltaRequest_default_instance_._instance,
  &::protocol::_TMReplayDeltaResponse_default_instance_._instance,
  &::protocol::_TMHaveTransactions_default_instance_._instance,
};

const char descriptor_table_protodef_src_2fripple_2fproto_2fripple_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035src/ripple/proto/ripple.proto\022\010protoco"
  "l\"\036\n\nTMManifest\022\020\n\010stobject\030\001 \002(\014\"F\n\013TMM"
  "anifests\022\"\n\004list\030\001 \003(\0132\024.protocol.TMMani"
  "fest\022\023\n\007history\030\002 \001(\010B\002\030\001\"k\n\rTMClusterNo"
  "de\022\021\n\tpublicKey\030\001 \002(\t\022\022\n\nreportTime\030\002 \002("
  "\r\022\020\n\010nodeLoad\030\003 \002(\r\022\020\n\010nodeName\030\004 \001(\t\022\017\n"
  "\007address\030\005 \001(\t\"9\n\014TMLoadSource\022\014\n\004name\030\001"
  " \002(\t\022\014\n\004cost\030\002 \002(\r\022\r\n\005count\030\003 \001(\r\"g\n\tTMC"
  "luster\022-\n\014clusterNodes\030\001 \003(\0132\027.protocol."
  "TMClusterNode\022+\n\013loadSources\030\002 \003(\0132\026.pro"
  "tocol.TMLoadSource\" \n\006TMLink\022\026\n\nnodePubK"
  "ey\030\001 \002(\014B\002\030\001\"e\n\022TMGetPeerShardInfo\022\020\n\004ho"
  "ps\030\001 \002(\rB\002\030\001\022\024\n\010lastLink\030\002 \001(\010B\002\030\001\022\'\n\tpe"
  "erChain\030\003 \003(\0132\020.protocol.TMLinkB\002\030\001\"\230\001\n\017"
  "TMPeerShardInfo\022\030\n\014shardIndexes\030\001 \002(\tB\002\030"
  "\001\022\026\n\nnodePubKey\030\002 \001(\014B\002\030\001\022\024\n\010endpoint\030\003 "
  "\001(\tB\002\030\001\022\024\n\010lastLink\030\004 \001(\010B\002\030\001\022\'\n\tpeerCha"
  "in\030\005 \003(\0132\020.protocol.TMLinkB\002\030\001\" \n\013TMPubl"
  "icKey\022\021\n\tpublicKey\030\001 \002(\014\"P\n\024TMGetPeerSha"
  "rdInfoV2\022(\n\tpeerChain\030\001 \003(\0132\025.protocol.T"
  "MPublicKey\022\016\n\006relays\030\002 \002(\r\"\214\002\n\021TMPeerSha"
  "rdInfoV2\022\021\n\ttimestamp\030\001 \002(\r\022<\n\nincomplet"
  "e\030\002 \003(\0132(.protocol.TMPeerShardInfoV2.TMI"
  "ncomplete\022\021\n\tfinalized\030\003 \001(\t\022\021\n\tpublicKe"
  "y\030\004 \002(\014\022\021\n\tsignature\030\005 \002(\014\022(\n\tpeerChain\030"
  "\006 \003(\0132\025.protocol.TMPublicKey\032C\n\014TMIncomp"
  "lete\022\022\n\nshardIndex\030\001 \002(\r\022\r\n\005state\030\002 \002(\r\022"
  "\020\n\010progress\030\003 \001(\r\"\200\001\n\rTMTransaction\022\026\n\016r"
  "awTransaction\030\001 \002(\014\022+\n\006status\030\002 \002(\0162\033.pr"
  "otocol.TransactionStatus\022\030\n\020receiveTimes"
  "tamp\030\003 \001(\004\022\020\n\010deferred\030\004 \001(\010\"\?\n\016TMTransa"
  "ctions\022-\n\014transactions\030\001 \003(\0132\027.protocol."
  "TMTransaction\"\333\001\n\016TMStatusChange\022\'\n\tnewS"
  "tatus\030\001 \001(\0162\024.protocol.NodeStatus\022%\n\010new"
  "Event\030\002 \001(\0162\023.protocol.NodeEvent\022\021\n\tledg"
  "erSeq\030\003 \001(\r\022\022\n\nledgerHash\030\004 \001(\014\022\032\n\022ledge"
  "rHashPrevious\030\005 \001(\014\022\023\n\013networkTime\030\006 \001(\004"
  "\022\020\n\010firstSeq\030\007 \001(\r\022\017\n\007lastSeq\030\010 \001(\r\"\206\002\n\014"
  "TMProposeSet\022\022\n\nproposeSeq\030\001 \002(\r\022\025\n\rcurr"
  "entTxHash\030\002 \002(\014\022\022\n\nnodePubKey\030\003 \002(\014\022\021\n\tc"
  "loseTime\030\004 \002(\r\022\021\n\tsignature\030\005 \002(\014\022\026\n\016pre"
  "viousledger\030\006 \002(\014\022\031\n\021addedTransactions\030\n"
  " \003(\014\022\033\n\023removedTransactions\030\013 \003(\014\022\034\n\020che"
  "ckedSignature\030\007 \001(\010B\002\030\001\022\020\n\004hops\030\014 \001(\rB\002\030"
  "\001\022\021\n\tledgerSeq\030\016 \001(\r\"K\n\024TMHaveTransactio"
  "nSet\022%\n\006status\030\001 \002(\0162\025.protocol.TxSetSta"
  "tus\022\014\n\004hash\030\002 \002(\014\"U\n\017TMValidatorList\022\020\n\010"
  "manifest\030\001 \002(\014\022\014\n\004blob\030\002 \002(\014\022\021\n\tsignatur"
  "e\030\003 \002(\014\022\017\n\007version\030\004 \002(\r\"F\n\021ValidatorBlo"
  "bInfo\022\020\n\010manifest\030\001 \001(\014\022\014\n\004blob\030\002 \002(\014\022\021\n"
  "\tsignature\030\003 \002(\014\"j\n\031TMValidatorListColle"
  "ction\022\017\n\007version\030\001 \002(\r\022\020\n\010manifest\030\002 \002(\014"
  "\022*\n\005blobs\030\003 \003(\0132\033.protocol.ValidatorBlob"
  "Info\"R\n\014TMValidation\022\022\n\nvalidation\030\001 \002(\014"
  "\022\034\n\020checkedSignature\030\002 \001(\010B\002\030\001\022\020\n\004hops\030\003"
  " \001(\rB\002\030\001\"\216\001\n\013TMEndpoints\022\017\n\007version\030\001 \002("
  "\r\0228\n\014endpoints_v2\030\003 \003(\0132\".protocol.TMEnd"
  "points.TMEndpointv2\032.\n\014TMEndpointv2\022\020\n\010e"
  "ndpoint\030\001 \002(\t\022\014\n\004hops\030\002 \002(\rJ\004\010\002\020\003\"_\n\017TMI"
  "ndexedObject\022\014\n\004hash\030\001 \001(\014\022\016\n\006nodeID\030\002 \001"
  "(\014\022\r\n\005index\030\003 \001(\014\022\014\n\004data\030\004 \001(\014\022\021\n\tledge"
  "rSeq\030\005 \001(\r\"\323\002\n\021TMGetObjectByHash\0224\n\004type"
  "\030\001 \002(\0162&.protocol.TMGetObjectByHash.Obje"
  "ctType\022\r\n\005query\030\002 \002(\010\022\013\n\003seq\030\003 \001(\r\022\022\n\nle"
  "dgerHash\030\004 \001(\014\022\013\n\003fat\030\005 \001(\010\022*\n\007objects\030\006"
  " \003(\0132\031.protocol.TMIndexedObject\"\236\001\n\nObje"
  "ctType\022\r\n\totUNKNOWN\020\000\022\014\n\010otLEDGER\020\001\022\021\n\ro"
  "tTRANSACTION\020\002\022\026\n\022otTRANSACTION_NODE\020\003\022\020"
  "\n\014otSTATE_NODE\020\004\022\020\n\014otCAS_OBJECT\020\005\022\020\n\014ot"
  "FETCH_PACK\020\006\022\022\n\016otTRANSACTIONS\020\007\"0\n\014TMLe"
  "dgerNode\022\020\n\010nodedata\030\001 \002(\014\022\016\n\006nodeid\030\002 \001"
  "(\014\"\354\001\n\013TMGetLedger\022)\n\005itype\030\001 \002(\0162\032.prot"
  "ocol.TMLedgerInfoType\022%\n\005ltype\030\002 \001(\0162\026.p"
  "rotocol.TMLedgerType\022\022\n\nledgerHash\030\003 \001(\014"
  "\022\021\n\tledgerSeq\030\004 \001(\r\022\017\n\007nodeIDs\030\005 \003(\014\022\025\n\r"
  "requestCookie\030\006 \001(\004\022(\n\tqueryType\030\007 \001(\0162\025"
  ".protocol.TMQueryType\022\022\n\nqueryDepth\030\010 \001("
  "\r\"\304\001\n\014TMLedgerData\022\022\n\nledgerHash\030\001 \002(\014\022\021"
  "\n\tledgerSeq\030\002 \002(\r\022(\n\004type\030\003 \002(\0162\032.protoc"
  "ol.TMLedgerInfoType\022%\n\005nodes\030\004 \003(\0132\026.pro"
  "tocol.TMLedgerNode\022\025\n\rrequestCookie\030\005 \001("
  "\r\022%\n\005error\030\006 \001(\0162\026.protocol.TMReplyError"
  "\"\205\001\n\006TMPing\022\'\n\004type\030\001 \002(\0162\031.protocol.TMP"
  "ing.pingType\022\013\n\003seq\030\002 \001(\r\022\020\n\010pingTime\030\003 "
  "\001(\004\022\017\n\007netTime\030\004 \001(\004\"\"\n\010pingType\022\n\n\006ptPI"
  "NG\020\000\022\n\n\006ptPONG\020\001\"N\n\tTMSquelch\022\017\n\007squelch"
  "\030\001 \002(\010\022\027\n\017validatorPubKey\030\002 \002(\014\022\027\n\017squel"
  "chDuration\030\003 \001(\r\"^\n\022TMProofPathRequest\022\013"
  "\n\003key\030\001 \002(\014\022\022\n\nledgerHash\030\002 \002(\014\022\'\n\004type\030"
  "\003 \002(\0162\031.protocol.TMLedgerMapType\"\252\001\n\023TMP"
  "roofPathResponse\022\013\n\003key\030\001 \002(\014\022\022\n\nledgerH"
  "ash\030\002 \002(\014\022\'\n\004type\030\003 \002(\0162\031.protocol.TMLed"
  "gerMapType\022\024\n\014ledgerHeader\030\004 \001(\014\022\014\n\004path"
  "\030\005 \003(\014\022%\n\005error\030\006 \001(\0162\026.protocol.TMReply"
  "Error\"*\n\024TMReplayDeltaRequest\022\022\n\nledgerH"
  "ash\030\001 \002(\014\"}\n\025TMReplayDeltaResponse\022\022\n\nle"
  "dgerHash\030\001 \002(\014\022\024\n\014ledgerHeader\030\002 \001(\014\022\023\n\013"
  "transaction\030\003 \003(\014\022%\n\005error\030\004 \001(\0162\026.proto"
  "col.TMReplyError\"$\n\022TMHaveTransactions\022\016"
  "\n\006hashes\030\001 \003(\014*\312\004\n\013MessageType\022\017\n\013mtMANI"
  "FESTS\020\002\022\n\n\006mtPING\020\003\022\r\n\tmtCLUSTER\020\005\022\017\n\013mt"
  "ENDPOINTS\020\017\022\021\n\rmtTRANSACTION\020\036\022\020\n\014mtGET_"
  "LEDGER\020\037\022\021\n\rmtLEDGER_DATA\020 \022\024\n\020mtPROPOSE"
  "_LEDGER\020!\022\023\n\017mtSTATUS_CHANGE\020\"\022\016\n\nmtHAVE"
  "_SET\020#\022\020\n\014mtVALIDATION\020)\022\021\n\rmtGET_OBJECT"
  "S\020*\022\024\n\020mtGET_SHARD_INFO\0202\022\020\n\014mtSHARD_INF"
  "O\0203\022\031\n\025mtGET_PEER_SHARD_INFO\0204\022\025\n\021mtPEER"
  "_SHARD_INFO\0205\022\023\n\017mtVALIDATORLIST\0206\022\r\n\tmt"
  "SQUELCH\0207\022\035\n\031mtVALIDATORLISTCOLLECTION\0208"
  "\022\024\n\020mtPROOF_PATH_REQ\0209\022\031\n\025mtPROOF_PATH_R"
  "ESPONSE\020:\022\026\n\022mtREPLAY_DELTA_REQ\020;\022\033\n\027mtR"
  "EPLAY_DELTA_RESPONSE\020<\022\034\n\030mtGET_PEER_SHA"
  "RD_INFO_V2\020=\022\030\n\024mtPEER_SHARD_INFO_V2\020>\022\027"
  "\n\023mtHAVE_TRANSACTIONS\020\?\022\022\n\016mtTRANSACTION"
  "S\020@*\241\001\n\021TransactionStatus\022\t\n\005tsNEW\020\001\022\r\n\t"
  "tsCURRENT\020\002\022\016\n\ntsCOMMITED\020\003\022\025\n\021tsREJECT_"
  "CONFLICT\020\004\022\024\n\020tsREJECT_INVALID\020\005\022\022\n\016tsRE"
  "JECT_FUNDS\020\006\022\016\n\ntsHELD_SEQ\020\007\022\021\n\rtsHELD_L"
  "EDGER\020\010*c\n\nNodeStatus\022\020\n\014nsCONNECTING\020\001\022"
  "\017\n\013nsCONNECTED\020\002\022\020\n\014nsMONITORING\020\003\022\020\n\014ns"
  "VALIDATING\020\004\022\016\n\nnsSHUTTING\020\005*`\n\tNodeEven"
  "t\022\024\n\020neCLOSING_LEDGER\020\001\022\025\n\021neACCEPTED_LE"
  "DGER\020\002\022\025\n\021neSWITCHED_LEDGER\020\003\022\017\n\013neLOST_"
  "SYNC\020\004*4\n\013TxSetStatus\022\n\n\006tsHAVE\020\001\022\r\n\ttsC"
  "AN_GET\020\002\022\n\n\006tsNEED\020\003*P\n\020TMLedgerInfoType"
  "\022\n\n\006liBASE\020\000\022\r\n\tliTX_NODE\020\001\022\r\n\tliAS_NODE"
  "\020\002\022\022\n\016liTS_CANDIDATE\020\003*;\n\014TMLedgerType\022\016"
  "\n\nltACCEPTED\020\000\022\r\n\tltCURRENT\020\001\022\014\n\010ltCLOSE"
  "D\020\002*\035\n\013TMQueryType\022\016\n\nqtINDIRECT\020\000*A\n\014TM"
  "ReplyError\022\017\n\013reNO_LEDGER\020\001\022\r\n\treNO_NODE"
  "\020\002\022\021\n\rreBAD_REQUEST\020\003*9\n\017TMLedgerMapType"
  "\022\021\n\rlmTRANASCTION\020\001\022\023\n\017lmACCOUNT_STATE\020\002"
  ;
static ::_pbi::once_flag descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_src_2fripple_2fproto_2fripple_2eproto = {
    false, false, 5280, descriptor_table_protodef_src_2fripple_2fproto_2fripple_2eproto,
    "src/ripple/proto/ripple.proto",
    &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once, nullptr, 0, 35,
    schemas, file_default_instances, TableStruct_src_2fripple_2fproto_2fripple_2eproto::offsets,
    file_level_metadata_src_2fripple_2fproto_2fripple_2eproto, file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto,
    file_level_service_descriptors_src_2fripple_2fproto_2fripple_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter() {
  return &descriptor_table_src_2fripple_2fproto_2fripple_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_src_2fripple_2fproto_2fripple_2eproto(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[0];
}
bool TMGetObjectByHash_ObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otUNKNOWN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otLEDGER;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otSTATE_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otCAS_OBJECT;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otFETCH_PACK;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTIONS;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MIN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MAX;
constexpr int TMGetObjectByHash::ObjectType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMPing_pingType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[1];
}
bool TMPing_pingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TMPing_pingType TMPing::ptPING;
constexpr TMPing_pingType TMPing::ptPONG;
constexpr TMPing_pingType TMPing::pingType_MIN;
constexpr TMPing_pingType TMPing::pingType_MAX;
constexpr int TMPing::pingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[2];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 2:
    case 3:
    case 5:
    case 15:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[3];
}
bool TransactionStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[4];
}
bool NodeStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[5];
}
bool NodeEvent_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxSetStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[6];
}
bool TxSetStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerInfoType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[7];
}
bool TMLedgerInfoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[8];
}
bool TMLedgerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMQueryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[9];
}
bool TMQueryType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMReplyError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[10];
}
bool TMReplyError_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerMapType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_src_2fripple_2fproto_2fripple_2eproto);
  return file_level_enum_descriptors_src_2fripple_2fproto_2fripple_2eproto[11];
}
bool TMLedgerMapType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TMManifest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMManifest>()._impl_._has_bits_);
  static void set_has_stobject(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMManifest::TMManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMManifest)
}
TMManifest::TMManifest(const TMManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMManifest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stobject_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stobject_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stobject_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stobject()) {
    _this->_impl_.stobject_.Set(from._internal_stobject(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifest)
}

inline void TMManifest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stobject_){}
  };
  _impl_.stobject_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stobject_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMManifest::~TMManifest() {
  // @@protoc_insertion_point(destructor:protocol.TMManifest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMManifest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stobject_.Destroy();
}

void TMManifest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stobject_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMManifest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes stobject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stobject();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMManifest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_stobject(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifest)
  return target;
}

size_t TMManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifest)
  size_t total_size = 0;

  // required bytes stobject = 1;
  if (_internal_has_stobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_stobject());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMManifest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMManifest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMManifest::GetClassData() const { return &_class_data_; }


void TMManifest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMManifest*>(&to_msg);
  auto& from = static_cast<const TMManifest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stobject()) {
    _this->_internal_set_stobject(from._internal_stobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMManifest::CopyFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMManifest::InternalSwap(TMManifest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stobject_, lhs_arena,
      &other->_impl_.stobject_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[0]);
}

// ===================================================================

class TMManifests::_Internal {
 public:
  using HasBits = decltype(std::declval<TMManifests>()._impl_._has_bits_);
  static void set_has_history(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TMManifests::TMManifests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMManifests)
}
TMManifests::TMManifests(const TMManifests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMManifests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.list_){from._impl_.list_}
    , decltype(_impl_.history_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.history_ = from._impl_.history_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifests)
}

inline void TMManifests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.list_){arena}
    , decltype(_impl_.history_){false}
  };
}

TMManifests::~TMManifests() {
  // @@protoc_insertion_point(destructor:protocol.TMManifests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMManifests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.list_.~RepeatedPtrField();
}

void TMManifests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMManifests::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.list_.Clear();
  _impl_.history_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMManifests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.TMManifest list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool history = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_history(&has_bits);
          _impl_.history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMManifests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_history(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifests)
  return target;
}

size_t TMManifests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  total_size += 1UL * this->_internal_list_size();
  for (const auto& msg : this->_impl_.list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool history = 2 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMManifests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMManifests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMManifests::GetClassData() const { return &_class_data_; }


void TMManifests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMManifests*>(&to_msg);
  auto& from = static_cast<const TMManifests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.list_.MergeFrom(from._impl_.list_);
  if (from._internal_has_history()) {
    _this->_internal_set_history(from._internal_history());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMManifests::CopyFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifests::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.list_))
    return false;
  return true;
}

void TMManifests::InternalSwap(TMManifests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.list_.InternalSwap(&other->_impl_.list_);
  swap(_impl_.history_, other->_impl_.history_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[1]);
}

// ===================================================================

class TMClusterNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TMClusterNode>()._impl_._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reporttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nodeload(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nodename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000019) ^ 0x00000019) != 0;
  }
};

TMClusterNode::TMClusterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMClusterNode)
}
TMClusterNode::TMClusterNode(const TMClusterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMClusterNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.nodename_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.reporttime_){}
    , decltype(_impl_.nodeload_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodename()) {
    _this->_impl_.nodename_.Set(from._internal_nodename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.reporttime_, &from._impl_.reporttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nodeload_) -
    reinterpret_cast<char*>(&_impl_.reporttime_)) + sizeof(_impl_.nodeload_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMClusterNode)
}

inline void TMClusterNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.nodename_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.reporttime_){0u}
    , decltype(_impl_.nodeload_){0u}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMClusterNode::~TMClusterNode() {
  // @@protoc_insertion_point(destructor:protocol.TMClusterNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMClusterNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.publickey_.Destroy();
  _impl_.nodename_.Destroy();
  _impl_.address_.Destroy();
}

void TMClusterNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMClusterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMClusterNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.nodename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.reporttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nodeload_) -
        reinterpret_cast<char*>(&_impl_.reporttime_)) + sizeof(_impl_.nodeload_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMClusterNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMClusterNode.publicKey");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 reportTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_reporttime(&has_bits);
          _impl_.reporttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 nodeLoad = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nodeload(&has_bits);
          _impl_.nodeload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string nodeName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nodename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMClusterNode.nodeName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMClusterNode.address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMClusterNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMClusterNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_publickey().data(), static_cast<int>(this->_internal_publickey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reporttime(), target);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nodeload(), target);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nodename().data(), static_cast<int>(this->_internal_nodename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nodename(), target);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMClusterNode)
  return target;
}

size_t TMClusterNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());
  }

  if (_internal_has_reporttime()) {
    // required uint32 reportTime = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reporttime());
  }

  if (_internal_has_nodeload()) {
    // required uint32 nodeLoad = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nodeload());
  }

  return total_size;
}
size_t TMClusterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());

    // required uint32 reportTime = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reporttime());

    // required uint32 nodeLoad = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nodeload());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string nodeName = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nodename());
    }

    // optional string address = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMClusterNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMClusterNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMClusterNode::GetClassData() const { return &_class_data_; }


void TMClusterNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMClusterNode*>(&to_msg);
  auto& from = static_cast<const TMClusterNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_nodename(from._internal_nodename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.reporttime_ = from._impl_.reporttime_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.nodeload_ = from._impl_.nodeload_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMClusterNode::CopyFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMClusterNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMClusterNode::InternalSwap(TMClusterNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodename_, lhs_arena,
      &other->_impl_.nodename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMClusterNode, _impl_.nodeload_)
      + sizeof(TMClusterNode::_impl_.nodeload_)
      - PROTOBUF_FIELD_OFFSET(TMClusterNode, _impl_.reporttime_)>(
          reinterpret_cast<char*>(&_impl_.reporttime_),
          reinterpret_cast<char*>(&other->_impl_.reporttime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMClusterNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[2]);
}

// ===================================================================

class TMLoadSource::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLoadSource>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMLoadSource::TMLoadSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLoadSource)
}
TMLoadSource::TMLoadSource(const TMLoadSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMLoadSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.cost_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cost_, &from._impl_.cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.cost_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLoadSource)
}

inline void TMLoadSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.cost_){0u}
    , decltype(_impl_.count_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMLoadSource::~TMLoadSource() {
  // @@protoc_insertion_point(destructor:protocol.TMLoadSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMLoadSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void TMLoadSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMLoadSource::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLoadSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.cost_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLoadSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMLoadSource.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cost(&has_bits);
          _impl_.cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMLoadSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLoadSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cost(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLoadSource)
  return target;
}

size_t TMLoadSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_cost()) {
    // required uint32 cost = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cost());
  }

  return total_size;
}
size_t TMLoadSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required uint32 cost = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cost());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 count = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMLoadSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMLoadSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMLoadSource::GetClassData() const { return &_class_data_; }


void TMLoadSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMLoadSource*>(&to_msg);
  auto& from = static_cast<const TMLoadSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cost_ = from._impl_.cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMLoadSource::CopyFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLoadSource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMLoadSource::InternalSwap(TMLoadSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMLoadSource, _impl_.count_)
      + sizeof(TMLoadSource::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(TMLoadSource, _impl_.cost_)>(
          reinterpret_cast<char*>(&_impl_.cost_),
          reinterpret_cast<char*>(&other->_impl_.cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLoadSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[3]);
}

// ===================================================================

class TMCluster::_Internal {
 public:
};

TMCluster::TMCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMCluster)
}
TMCluster::TMCluster(const TMCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMCluster* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.clusternodes_){from._impl_.clusternodes_}
    , decltype(_impl_.loadsources_){from._impl_.loadsources_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMCluster)
}

inline void TMCluster::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.clusternodes_){arena}
    , decltype(_impl_.loadsources_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TMCluster::~TMCluster() {
  // @@protoc_insertion_point(destructor:protocol.TMCluster)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMCluster::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clusternodes_.~RepeatedPtrField();
  _impl_.loadsources_.~RepeatedPtrField();
}

void TMCluster::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMCluster)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.clusternodes_.Clear();
  _impl_.loadsources_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMCluster::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clusternodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loadsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMCluster::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMCluster)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_clusternodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_clusternodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loadsources_size()); i < n; i++) {
    const auto& repfield = this->_internal_loadsources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMCluster)
  return target;
}

size_t TMCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMCluster)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  total_size += 1UL * this->_internal_clusternodes_size();
  for (const auto& msg : this->_impl_.clusternodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  total_size += 1UL * this->_internal_loadsources_size();
  for (const auto& msg : this->_impl_.loadsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMCluster::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMCluster::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMCluster::GetClassData() const { return &_class_data_; }


void TMCluster::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMCluster*>(&to_msg);
  auto& from = static_cast<const TMCluster&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.clusternodes_.MergeFrom(from._impl_.clusternodes_);
  _this->_impl_.loadsources_.MergeFrom(from._impl_.loadsources_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMCluster::CopyFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMCluster::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.clusternodes_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.loadsources_))
    return false;
  return true;
}

void TMCluster::InternalSwap(TMCluster* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.clusternodes_.InternalSwap(&other->_impl_.clusternodes_);
  _impl_.loadsources_.InternalSwap(&other->_impl_.loadsources_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMCluster::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[4]);
}

// ===================================================================

class TMLink::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLink>()._impl_._has_bits_);
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMLink::TMLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLink)
}
TMLink::TMLink(const TMLink& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMLink* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodepubkey_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nodepubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodepubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodepubkey()) {
    _this->_impl_.nodepubkey_.Set(from._internal_nodepubkey(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLink)
}

inline void TMLink::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodepubkey_){}
  };
  _impl_.nodepubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodepubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMLink::~TMLink() {
  // @@protoc_insertion_point(destructor:protocol.TMLink)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMLink::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodepubkey_.Destroy();
}

void TMLink::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMLink::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLink)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.nodepubkey_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLink::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes nodePubKey = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMLink::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLink)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes nodePubKey = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nodepubkey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLink)
  return target;
}

size_t TMLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLink)
  size_t total_size = 0;

  // required bytes nodePubKey = 1 [deprecated = true];
  if (_internal_has_nodepubkey()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMLink::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMLink::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMLink::GetClassData() const { return &_class_data_; }


void TMLink::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMLink*>(&to_msg);
  auto& from = static_cast<const TMLink&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nodepubkey()) {
    _this->_internal_set_nodepubkey(from._internal_nodepubkey());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMLink::CopyFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLink::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMLink::InternalSwap(TMLink* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodepubkey_, lhs_arena,
      &other->_impl_.nodepubkey_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLink::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[5]);
}

// ===================================================================

class TMGetPeerShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetPeerShardInfo>()._impl_._has_bits_);
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMGetPeerShardInfo::TMGetPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetPeerShardInfo)
}
TMGetPeerShardInfo::TMGetPeerShardInfo(const TMGetPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMGetPeerShardInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peerchain_){from._impl_.peerchain_}
    , decltype(_impl_.hops_){}
    , decltype(_impl_.lastlink_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hops_, &from._impl_.hops_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lastlink_) -
    reinterpret_cast<char*>(&_impl_.hops_)) + sizeof(_impl_.lastlink_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeerShardInfo)
}

inline void TMGetPeerShardInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peerchain_){arena}
    , decltype(_impl_.hops_){0u}
    , decltype(_impl_.lastlink_){false}
  };
}

TMGetPeerShardInfo::~TMGetPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeerShardInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMGetPeerShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peerchain_.~RepeatedPtrField();
}

void TMGetPeerShardInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMGetPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeerShardInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peerchain_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.hops_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lastlink_) -
        reinterpret_cast<char*>(&_impl_.hops_)) + sizeof(_impl_.lastlink_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetPeerShardInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 hops = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hops(&has_bits);
          _impl_.hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool lastLink = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lastlink(&has_bits);
          _impl_.lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMGetPeerShardInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeerShardInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 hops = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hops(), target);
  }

  // optional bool lastLink = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peerchain_size()); i < n; i++) {
    const auto& repfield = this->_internal_peerchain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeerShardInfo)
  return target;
}

size_t TMGetPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeerShardInfo)
  size_t total_size = 0;

  // required uint32 hops = 1 [deprecated = true];
  if (_internal_has_hops()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hops());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->_impl_.peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool lastLink = 2 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMGetPeerShardInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMGetPeerShardInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMGetPeerShardInfo::GetClassData() const { return &_class_data_; }


void TMGetPeerShardInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMGetPeerShardInfo*>(&to_msg);
  auto& from = static_cast<const TMGetPeerShardInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peerchain_.MergeFrom(from._impl_.peerchain_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hops_ = from._impl_.hops_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lastlink_ = from._impl_.lastlink_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMGetPeerShardInfo::CopyFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeerShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.peerchain_))
    return false;
  return true;
}

void TMGetPeerShardInfo::InternalSwap(TMGetPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.peerchain_.InternalSwap(&other->_impl_.peerchain_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetPeerShardInfo, _impl_.lastlink_)
      + sizeof(TMGetPeerShardInfo::_impl_.lastlink_)
      - PROTOBUF_FIELD_OFFSET(TMGetPeerShardInfo, _impl_.hops_)>(
          reinterpret_cast<char*>(&_impl_.hops_),
          reinterpret_cast<char*>(&other->_impl_.hops_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetPeerShardInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[6]);
}

// ===================================================================

class TMPeerShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfo>()._impl_._has_bits_);
  static void set_has_shardindexes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPeerShardInfo::TMPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfo)
}
TMPeerShardInfo::TMPeerShardInfo(const TMPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMPeerShardInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peerchain_){from._impl_.peerchain_}
    , decltype(_impl_.shardindexes_){}
    , decltype(_impl_.nodepubkey_){}
    , decltype(_impl_.endpoint_){}
    , decltype(_impl_.lastlink_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.shardindexes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shardindexes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shardindexes()) {
    _this->_impl_.shardindexes_.Set(from._internal_shardindexes(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodepubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodepubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodepubkey()) {
    _this->_impl_.nodepubkey_.Set(from._internal_nodepubkey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.endpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint()) {
    _this->_impl_.endpoint_.Set(from._internal_endpoint(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.lastlink_ = from._impl_.lastlink_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfo)
}

inline void TMPeerShardInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peerchain_){arena}
    , decltype(_impl_.shardindexes_){}
    , decltype(_impl_.nodepubkey_){}
    , decltype(_impl_.endpoint_){}
    , decltype(_impl_.lastlink_){false}
  };
  _impl_.shardindexes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shardindexes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodepubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodepubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMPeerShardInfo::~TMPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMPeerShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peerchain_.~RepeatedPtrField();
  _impl_.shardindexes_.Destroy();
  _impl_.nodepubkey_.Destroy();
  _impl_.endpoint_.Destroy();
}

void TMPeerShardInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peerchain_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.shardindexes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.endpoint_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.lastlink_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string shardIndexes = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_shardindexes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMPeerShardInfo.shardIndexes");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodePubKey = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string endpoint = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMPeerShardInfo.endpoint");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool lastLink = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_lastlink(&has_bits);
          _impl_.lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMPeerShardInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string shardIndexes = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shardindexes().data(), static_cast<int>(this->_internal_shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.shardIndexes");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_shardindexes(), target);
  }

  // optional bytes nodePubKey = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodepubkey(), target);
  }

  // optional string endpoint = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.endpoint");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_endpoint(), target);
  }

  // optional bool lastLink = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peerchain_size()); i < n; i++) {
    const auto& repfield = this->_internal_peerchain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfo)
  return target;
}

size_t TMPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfo)
  size_t total_size = 0;

  // required string shardIndexes = 1 [deprecated = true];
  if (_internal_has_shardindexes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shardindexes());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->_impl_.peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes nodePubKey = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodepubkey());
    }

    // optional string endpoint = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint());
    }

    // optional bool lastLink = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMPeerShardInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMPeerShardInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMPeerShardInfo::GetClassData() const { return &_class_data_; }


void TMPeerShardInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMPeerShardInfo*>(&to_msg);
  auto& from = static_cast<const TMPeerShardInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peerchain_.MergeFrom(from._impl_.peerchain_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_shardindexes(from._internal_shardindexes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lastlink_ = from._impl_.lastlink_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMPeerShardInfo::CopyFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.peerchain_))
    return false;
  return true;
}

void TMPeerShardInfo::InternalSwap(TMPeerShardInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.peerchain_.InternalSwap(&other->_impl_.peerchain_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.shardindexes_, lhs_arena,
      &other->_impl_.shardindexes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodepubkey_, lhs_arena,
      &other->_impl_.nodepubkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.endpoint_, lhs_arena,
      &other->_impl_.endpoint_, rhs_arena
  );
  swap(_impl_.lastlink_, other->_impl_.lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[7]);
}

// ===================================================================

class TMPublicKey::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPublicKey>()._impl_._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPublicKey::TMPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPublicKey)
}
TMPublicKey::TMPublicKey(const TMPublicKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMPublicKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMPublicKey)
}

inline void TMPublicKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publickey_){}
  };
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMPublicKey::~TMPublicKey() {
  // @@protoc_insertion_point(destructor:protocol.TMPublicKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMPublicKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.publickey_.Destroy();
}

void TMPublicKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPublicKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.publickey_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPublicKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMPublicKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPublicKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPublicKey)
  return target;
}

size_t TMPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPublicKey)
  size_t total_size = 0;

  // required bytes publicKey = 1;
  if (_internal_has_publickey()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMPublicKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMPublicKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMPublicKey::GetClassData() const { return &_class_data_; }


void TMPublicKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMPublicKey*>(&to_msg);
  auto& from = static_cast<const TMPublicKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPublicKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_publickey()) {
    _this->_internal_set_publickey(from._internal_publickey());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMPublicKey::CopyFrom(const TMPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPublicKey::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMPublicKey::InternalSwap(TMPublicKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPublicKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[8]);
}

// ===================================================================

class TMGetPeerShardInfoV2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetPeerShardInfoV2>()._impl_._has_bits_);
  static void set_has_relays(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMGetPeerShardInfoV2::TMGetPeerShardInfoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetPeerShardInfoV2)
}
TMGetPeerShardInfoV2::TMGetPeerShardInfoV2(const TMGetPeerShardInfoV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMGetPeerShardInfoV2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peerchain_){from._impl_.peerchain_}
    , decltype(_impl_.relays_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.relays_ = from._impl_.relays_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeerShardInfoV2)
}

inline void TMGetPeerShardInfoV2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.peerchain_){arena}
    , decltype(_impl_.relays_){0u}
  };
}

TMGetPeerShardInfoV2::~TMGetPeerShardInfoV2() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeerShardInfoV2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMGetPeerShardInfoV2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peerchain_.~RepeatedPtrField();
}

void TMGetPeerShardInfoV2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMGetPeerShardInfoV2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeerShardInfoV2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peerchain_.Clear();
  _impl_.relays_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetPeerShardInfoV2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.TMPublicKey peerChain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required uint32 relays = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_relays(&has_bits);
          _impl_.relays_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMGetPeerShardInfoV2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeerShardInfoV2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMPublicKey peerChain = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peerchain_size()); i < n; i++) {
    const auto& repfield = this->_internal_peerchain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 relays = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_relays(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeerShardInfoV2)
  return target;
}

size_t TMGetPeerShardInfoV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeerShardInfoV2)
  size_t total_size = 0;

  // required uint32 relays = 2;
  if (_internal_has_relays()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_relays());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMPublicKey peerChain = 1;
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->_impl_.peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMGetPeerShardInfoV2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMGetPeerShardInfoV2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMGetPeerShardInfoV2::GetClassData() const { return &_class_data_; }


void TMGetPeerShardInfoV2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMGetPeerShardInfoV2*>(&to_msg);
  auto& from = static_cast<const TMGetPeerShardInfoV2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeerShardInfoV2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peerchain_.MergeFrom(from._impl_.peerchain_);
  if (from._internal_has_relays()) {
    _this->_internal_set_relays(from._internal_relays());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMGetPeerShardInfoV2::CopyFrom(const TMGetPeerShardInfoV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeerShardInfoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeerShardInfoV2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.peerchain_))
    return false;
  return true;
}

void TMGetPeerShardInfoV2::InternalSwap(TMGetPeerShardInfoV2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.peerchain_.InternalSwap(&other->_impl_.peerchain_);
  swap(_impl_.relays_, other->_impl_.relays_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetPeerShardInfoV2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[9]);
}

// ===================================================================

class TMPeerShardInfoV2_TMIncomplete::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfoV2_TMIncomplete>()._impl_._has_bits_);
  static void set_has_shardindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMPeerShardInfoV2_TMIncomplete::TMPeerShardInfoV2_TMIncomplete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfoV2.TMIncomplete)
}
TMPeerShardInfoV2_TMIncomplete::TMPeerShardInfoV2_TMIncomplete(const TMPeerShardInfoV2_TMIncomplete& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMPeerShardInfoV2_TMIncomplete* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shardindex_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.progress_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardindex_, &from._impl_.shardindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.progress_) -
    reinterpret_cast<char*>(&_impl_.shardindex_)) + sizeof(_impl_.progress_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfoV2.TMIncomplete)
}

inline void TMPeerShardInfoV2_TMIncomplete::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shardindex_){0u}
    , decltype(_impl_.state_){0u}
    , decltype(_impl_.progress_){0u}
  };
}

TMPeerShardInfoV2_TMIncomplete::~TMPeerShardInfoV2_TMIncomplete() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfoV2.TMIncomplete)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMPeerShardInfoV2_TMIncomplete::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TMPeerShardInfoV2_TMIncomplete::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMPeerShardInfoV2_TMIncomplete::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.shardindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.progress_) -
        reinterpret_cast<char*>(&_impl_.shardindex_)) + sizeof(_impl_.progress_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfoV2_TMIncomplete::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 shardIndex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_shardindex(&has_bits);
          _impl_.shardindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 progress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMPeerShardInfoV2_TMIncomplete::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 shardIndex = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_shardindex(), target);
  }

  // required uint32 state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_state(), target);
  }

  // optional uint32 progress = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfoV2.TMIncomplete)
  return target;
}

size_t TMPeerShardInfoV2_TMIncomplete::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  size_t total_size = 0;

  if (_internal_has_shardindex()) {
    // required uint32 shardIndex = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shardindex());
  }

  if (_internal_has_state()) {
    // required uint32 state = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());
  }

  return total_size;
}
size_t TMPeerShardInfoV2_TMIncomplete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 shardIndex = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shardindex());

    // required uint32 state = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 progress = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_progress());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMPeerShardInfoV2_TMIncomplete::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMPeerShardInfoV2_TMIncomplete::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMPeerShardInfoV2_TMIncomplete::GetClassData() const { return &_class_data_; }


void TMPeerShardInfoV2_TMIncomplete::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMPeerShardInfoV2_TMIncomplete*>(&to_msg);
  auto& from = static_cast<const TMPeerShardInfoV2_TMIncomplete&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.shardindex_ = from._impl_.shardindex_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMPeerShardInfoV2_TMIncomplete::CopyFrom(const TMPeerShardInfoV2_TMIncomplete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfoV2_TMIncomplete::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMPeerShardInfoV2_TMIncomplete::InternalSwap(TMPeerShardInfoV2_TMIncomplete* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMPeerShardInfoV2_TMIncomplete, _impl_.progress_)
      + sizeof(TMPeerShardInfoV2_TMIncomplete::_impl_.progress_)
      - PROTOBUF_FIELD_OFFSET(TMPeerShardInfoV2_TMIncomplete, _impl_.shardindex_)>(
          reinterpret_cast<char*>(&_impl_.shardindex_),
          reinterpret_cast<char*>(&other->_impl_.shardindex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfoV2_TMIncomplete::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[10]);
}

// ===================================================================

class TMPeerShardInfoV2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfoV2>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_finalized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

TMPeerShardInfoV2::TMPeerShardInfoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfoV2)
}
TMPeerShardInfoV2::TMPeerShardInfoV2(const TMPeerShardInfoV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMPeerShardInfoV2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incomplete_){from._impl_.incomplete_}
    , decltype(_impl_.peerchain_){from._impl_.peerchain_}
    , decltype(_impl_.finalized_){}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.finalized_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.finalized_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_finalized()) {
    _this->_impl_.finalized_.Set(from._internal_finalized(), 
      _this->GetArenaForAllocation());
  }
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey()) {
    _this->_impl_.publickey_.Set(from._internal_publickey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfoV2)
}

inline void TMPeerShardInfoV2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incomplete_){arena}
    , decltype(_impl_.peerchain_){arena}
    , decltype(_impl_.finalized_){}
    , decltype(_impl_.publickey_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.timestamp_){0u}
  };
  _impl_.finalized_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.finalized_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.publickey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publickey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMPeerShardInfoV2::~TMPeerShardInfoV2() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfoV2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMPeerShardInfoV2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.incomplete_.~RepeatedPtrField();
  _impl_.peerchain_.~RepeatedPtrField();
  _impl_.finalized_.Destroy();
  _impl_.publickey_.Destroy();
  _impl_.signature_.Destroy();
}

void TMPeerShardInfoV2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMPeerShardInfoV2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfoV2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.incomplete_.Clear();
  _impl_.peerchain_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.finalized_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfoV2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incomplete(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string finalized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_finalized();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMPeerShardInfoV2.finalized");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required bytes publicKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_publickey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMPublicKey peerChain = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMPeerShardInfoV2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfoV2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 timestamp = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_timestamp(), target);
  }

  // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incomplete_size()); i < n; i++) {
    const auto& repfield = this->_internal_incomplete(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string finalized = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_finalized().data(), static_cast<int>(this->_internal_finalized().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfoV2.finalized");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_finalized(), target);
  }

  // required bytes publicKey = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_publickey(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // repeated .protocol.TMPublicKey peerChain = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peerchain_size()); i < n; i++) {
    const auto& repfield = this->_internal_peerchain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfoV2)
  return target;
}

size_t TMPeerShardInfoV2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMPeerShardInfoV2)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required bytes publicKey = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_timestamp()) {
    // required uint32 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
  }

  return total_size;
}
size_t TMPeerShardInfoV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfoV2)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required bytes publicKey = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());

    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required uint32 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
  total_size += 1UL * this->_internal_incomplete_size();
  for (const auto& msg : this->_impl_.incomplete_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.TMPublicKey peerChain = 6;
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->_impl_.peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string finalized = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_finalized());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMPeerShardInfoV2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMPeerShardInfoV2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMPeerShardInfoV2::GetClassData() const { return &_class_data_; }


void TMPeerShardInfoV2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMPeerShardInfoV2*>(&to_msg);
  auto& from = static_cast<const TMPeerShardInfoV2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfoV2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.incomplete_.MergeFrom(from._impl_.incomplete_);
  _this->_impl_.peerchain_.MergeFrom(from._impl_.peerchain_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_finalized(from._internal_finalized());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMPeerShardInfoV2::CopyFrom(const TMPeerShardInfoV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfoV2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.incomplete_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.peerchain_))
    return false;
  return true;
}

void TMPeerShardInfoV2::InternalSwap(TMPeerShardInfoV2* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.incomplete_.InternalSwap(&other->_impl_.incomplete_);
  _impl_.peerchain_.InternalSwap(&other->_impl_.peerchain_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.finalized_, lhs_arena,
      &other->_impl_.finalized_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publickey_, lhs_arena,
      &other->_impl_.publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfoV2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[11]);
}

// ===================================================================

class TMTransaction::_Internal {
 public:
  using HasBits = decltype(std::declval<TMTransaction>()._impl_._has_bits_);
  static void set_has_rawtransaction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receivetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deferred(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

TMTransaction::TMTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMTransaction)
}
TMTransaction::TMTransaction(const TMTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMTransaction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rawtransaction_){}
    , decltype(_impl_.receivetimestamp_){}
    , decltype(_impl_.deferred_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rawtransaction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rawtransaction_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rawtransaction()) {
    _this->_impl_.rawtransaction_.Set(from._internal_rawtransaction(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.receivetimestamp_, &from._impl_.receivetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.receivetimestamp_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransaction)
}

inline void TMTransaction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rawtransaction_){}
    , decltype(_impl_.receivetimestamp_){uint64_t{0u}}
    , decltype(_impl_.deferred_){false}
    , decltype(_impl_.status_){1}
  };
  _impl_.rawtransaction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rawtransaction_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMTransaction::~TMTransaction() {
  // @@protoc_insertion_point(destructor:protocol.TMTransaction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMTransaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rawtransaction_.Destroy();
}

void TMTransaction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rawtransaction_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.receivetimestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.deferred_) -
        reinterpret_cast<char*>(&_impl_.receivetimestamp_)) + sizeof(_impl_.deferred_));
    _impl_.status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMTransaction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes rawTransaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_rawtransaction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .protocol.TransactionStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TransactionStatus_IsValid(val))) {
            _internal_set_status(static_cast<::protocol::TransactionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 receiveTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_receivetimestamp(&has_bits);
          _impl_.receivetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool deferred = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_deferred(&has_bits);
          _impl_.deferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMTransaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_rawtransaction(), target);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_receivetimestamp(), target);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_deferred(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransaction)
  return target;
}

size_t TMTransaction::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (_internal_has_rawtransaction()) {
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawtransaction());
  }

  if (_internal_has_status()) {
    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t TMTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawtransaction());

    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 receiveTimestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_receivetimestamp());
    }

    // optional bool deferred = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMTransaction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMTransaction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMTransaction::GetClassData() const { return &_class_data_; }


void TMTransaction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMTransaction*>(&to_msg);
  auto& from = static_cast<const TMTransaction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rawtransaction(from._internal_rawtransaction());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.receivetimestamp_ = from._impl_.receivetimestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.deferred_ = from._impl_.deferred_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMTransaction::CopyFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransaction::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMTransaction::InternalSwap(TMTransaction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rawtransaction_, lhs_arena,
      &other->_impl_.rawtransaction_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMTransaction, _impl_.deferred_)
      + sizeof(TMTransaction::_impl_.deferred_)
      - PROTOBUF_FIELD_OFFSET(TMTransaction, _impl_.receivetimestamp_)>(
          reinterpret_cast<char*>(&_impl_.receivetimestamp_),
          reinterpret_cast<char*>(&other->_impl_.receivetimestamp_));
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMTransaction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[12]);
}

// ===================================================================

class TMTransactions::_Internal {
 public:
};

TMTransactions::TMTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMTransactions)
}
TMTransactions::TMTransactions(const TMTransactions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMTransactions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){from._impl_.transactions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransactions)
}

inline void TMTransactions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TMTransactions::~TMTransactions() {
  // @@protoc_insertion_point(destructor:protocol.TMTransactions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMTransactions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
}

void TMTransactions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMTransactions::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransactions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMTransactions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.TMTransaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMTransactions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransactions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMTransaction transactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransactions)
  return target;
}

size_t TMTransactions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransactions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMTransaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMTransactions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMTransactions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMTransactions::GetClassData() const { return &_class_data_; }


void TMTransactions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMTransactions*>(&to_msg);
  auto& from = static_cast<const TMTransactions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransactions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMTransactions::CopyFrom(const TMTransactions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransactions::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.transactions_))
    return false;
  return true;
}

void TMTransactions::InternalSwap(TMTransactions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMTransactions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[13]);
}

// ===================================================================

class TMStatusChange::_Internal {
 public:
  using HasBits = decltype(std::declval<TMStatusChange>()._impl_._has_bits_);
  static void set_has_newstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newevent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhashprevious(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_networktime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_firstseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lastseq(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TMStatusChange::TMStatusChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMStatusChange)
}
TMStatusChange::TMStatusChange(const TMStatusChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMStatusChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerhashprevious_){}
    , decltype(_impl_.ledgerseq_){}
    , decltype(_impl_.firstseq_){}
    , decltype(_impl_.networktime_){}
    , decltype(_impl_.lastseq_){}
    , decltype(_impl_.newstatus_){}
    , decltype(_impl_.newevent_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ledgerhashprevious_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhashprevious_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhashprevious()) {
    _this->_impl_.ledgerhashprevious_.Set(from._internal_ledgerhashprevious(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ledgerseq_, &from._impl_.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.newevent_) -
    reinterpret_cast<char*>(&_impl_.ledgerseq_)) + sizeof(_impl_.newevent_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMStatusChange)
}

inline void TMStatusChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerhashprevious_){}
    , decltype(_impl_.ledgerseq_){0u}
    , decltype(_impl_.firstseq_){0u}
    , decltype(_impl_.networktime_){uint64_t{0u}}
    , decltype(_impl_.lastseq_){0u}
    , decltype(_impl_.newstatus_){1}
    , decltype(_impl_.newevent_){1}
  };
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ledgerhashprevious_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhashprevious_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMStatusChange::~TMStatusChange() {
  // @@protoc_insertion_point(destructor:protocol.TMStatusChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMStatusChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ledgerhash_.Destroy();
  _impl_.ledgerhashprevious_.Destroy();
}

void TMStatusChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMStatusChange::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMStatusChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ledgerhashprevious_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lastseq_) -
        reinterpret_cast<char*>(&_impl_.ledgerseq_)) + sizeof(_impl_.lastseq_));
    _impl_.newstatus_ = 1;
    _impl_.newevent_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMStatusChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeStatus_IsValid(val))) {
            _internal_set_newstatus(static_cast<::protocol::NodeStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .protocol.NodeEvent newEvent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeEvent_IsValid(val))) {
            _internal_set_newevent(static_cast<::protocol::NodeEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ledgerseq(&has_bits);
          _impl_.ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ledgerHashPrevious = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ledgerhashprevious();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 networkTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_networktime(&has_bits);
          _impl_.networktime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 firstSeq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_firstseq(&has_bits);
          _impl_.firstseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lastSeq = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_lastseq(&has_bits);
          _impl_.lastseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMStatusChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMStatusChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_newstatus(), target);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_newevent(), target);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ledgerseq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerhash(), target);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_ledgerhashprevious(), target);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_networktime(), target);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_firstseq(), target);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_lastseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMStatusChange)
  return target;
}

size_t TMStatusChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMStatusChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes ledgerHash = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerhash());
    }

    // optional bytes ledgerHashPrevious = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerhashprevious());
    }

    // optional uint32 ledgerSeq = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledgerseq());
    }

    // optional uint32 firstSeq = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_firstseq());
    }

    // optional uint64 networkTime = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_networktime());
    }

    // optional uint32 lastSeq = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lastseq());
    }

    // optional .protocol.NodeStatus newStatus = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_newstatus());
    }

    // optional .protocol.NodeEvent newEvent = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_newevent());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMStatusChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMStatusChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMStatusChange::GetClassData() const { return &_class_data_; }


void TMStatusChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMStatusChange*>(&to_msg);
  auto& from = static_cast<const TMStatusChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ledgerhashprevious(from._internal_ledgerhashprevious());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ledgerseq_ = from._impl_.ledgerseq_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.firstseq_ = from._impl_.firstseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.networktime_ = from._impl_.networktime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lastseq_ = from._impl_.lastseq_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.newstatus_ = from._impl_.newstatus_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.newevent_ = from._impl_.newevent_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMStatusChange::CopyFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMStatusChange::IsInitialized() const {
  return true;
}

void TMStatusChange::InternalSwap(TMStatusChange* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhashprevious_, lhs_arena,
      &other->_impl_.ledgerhashprevious_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMStatusChange, _impl_.lastseq_)
      + sizeof(TMStatusChange::_impl_.lastseq_)
      - PROTOBUF_FIELD_OFFSET(TMStatusChange, _impl_.ledgerseq_)>(
          reinterpret_cast<char*>(&_impl_.ledgerseq_),
          reinterpret_cast<char*>(&other->_impl_.ledgerseq_));
  swap(_impl_.newstatus_, other->_impl_.newstatus_);
  swap(_impl_.newevent_, other->_impl_.newevent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMStatusChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[14]);
}

// ===================================================================

class TMProposeSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProposeSet>()._impl_._has_bits_);
  static void set_has_proposeseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_currenttxhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_closetime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_previousledger(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

TMProposeSet::TMProposeSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProposeSet)
}
TMProposeSet::TMProposeSet(const TMProposeSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMProposeSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addedtransactions_){from._impl_.addedtransactions_}
    , decltype(_impl_.removedtransactions_){from._impl_.removedtransactions_}
    , decltype(_impl_.currenttxhash_){}
    , decltype(_impl_.nodepubkey_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.previousledger_){}
    , decltype(_impl_.proposeseq_){}
    , decltype(_impl_.closetime_){}
    , decltype(_impl_.checkedsignature_){}
    , decltype(_impl_.hops_){}
    , decltype(_impl_.ledgerseq_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.currenttxhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currenttxhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currenttxhash()) {
    _this->_impl_.currenttxhash_.Set(from._internal_currenttxhash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodepubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodepubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodepubkey()) {
    _this->_impl_.nodepubkey_.Set(from._internal_nodepubkey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.previousledger_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.previousledger_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_previousledger()) {
    _this->_impl_.previousledger_.Set(from._internal_previousledger(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.proposeseq_, &from._impl_.proposeseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ledgerseq_) -
    reinterpret_cast<char*>(&_impl_.proposeseq_)) + sizeof(_impl_.ledgerseq_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProposeSet)
}

inline void TMProposeSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addedtransactions_){arena}
    , decltype(_impl_.removedtransactions_){arena}
    , decltype(_impl_.currenttxhash_){}
    , decltype(_impl_.nodepubkey_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.previousledger_){}
    , decltype(_impl_.proposeseq_){0u}
    , decltype(_impl_.closetime_){0u}
    , decltype(_impl_.checkedsignature_){false}
    , decltype(_impl_.hops_){0u}
    , decltype(_impl_.ledgerseq_){0u}
  };
  _impl_.currenttxhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currenttxhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodepubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodepubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.previousledger_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.previousledger_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMProposeSet::~TMProposeSet() {
  // @@protoc_insertion_point(destructor:protocol.TMProposeSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMProposeSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.addedtransactions_.~RepeatedPtrField();
  _impl_.removedtransactions_.~RepeatedPtrField();
  _impl_.currenttxhash_.Destroy();
  _impl_.nodepubkey_.Destroy();
  _impl_.signature_.Destroy();
  _impl_.previousledger_.Destroy();
}

void TMProposeSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMProposeSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProposeSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.addedtransactions_.Clear();
  _impl_.removedtransactions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currenttxhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.previousledger_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.proposeseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hops_) -
        reinterpret_cast<char*>(&_impl_.proposeseq_)) + sizeof(_impl_.hops_));
  }
  _impl_.ledgerseq_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProposeSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 proposeSeq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_proposeseq(&has_bits);
          _impl_.proposeseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes currentTxHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_currenttxhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes nodePubKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 closeTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_closetime(&has_bits);
          _impl_.closetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes previousledger = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_previousledger();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool checkedSignature = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_checkedsignature(&has_bits);
          _impl_.checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes addedTransactions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_addedtransactions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes removedTransactions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_removedtransactions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hops = 12 [deprecated = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_hops(&has_bits);
          _impl_.hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_ledgerseq(&has_bits);
          _impl_.ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMProposeSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProposeSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_proposeseq(), target);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_currenttxhash(), target);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_nodepubkey(), target);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_closetime(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_previousledger(), target);
  }

  // optional bool checkedSignature = 7 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_checkedsignature(), target);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->_internal_addedtransactions_size(); i < n; i++) {
    const auto& s = this->_internal_addedtransactions(i);
    target = stream->WriteBytes(10, s, target);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->_internal_removedtransactions_size(); i < n; i++) {
    const auto& s = this->_internal_removedtransactions(i);
    target = stream->WriteBytes(11, s, target);
  }

  // optional uint32 hops = 12 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_hops(), target);
  }

  // optional uint32 ledgerSeq = 14;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_ledgerseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProposeSet)
  return target;
}

size_t TMProposeSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (_internal_has_currenttxhash()) {
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_currenttxhash());
  }

  if (_internal_has_nodepubkey()) {
    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_previousledger()) {
    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_previousledger());
  }

  if (_internal_has_proposeseq()) {
    // required uint32 proposeSeq = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_proposeseq());
  }

  if (_internal_has_closetime()) {
    // required uint32 closeTime = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_closetime());
  }

  return total_size;
}
size_t TMProposeSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_currenttxhash());

    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());

    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_previousledger());

    // required uint32 proposeSeq = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_proposeseq());

    // required uint32 closeTime = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_closetime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes addedTransactions = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.addedtransactions_.size());
  for (int i = 0, n = _impl_.addedtransactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.addedtransactions_.Get(i));
  }

  // repeated bytes removedTransactions = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.removedtransactions_.size());
  for (int i = 0, n = _impl_.removedtransactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.removedtransactions_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional bool checkedSignature = 7 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 12 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hops());
    }

  }
  // optional uint32 ledgerSeq = 14;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledgerseq());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMProposeSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMProposeSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMProposeSet::GetClassData() const { return &_class_data_; }


void TMProposeSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMProposeSet*>(&to_msg);
  auto& from = static_cast<const TMProposeSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.addedtransactions_.MergeFrom(from._impl_.addedtransactions_);
  _this->_impl_.removedtransactions_.MergeFrom(from._impl_.removedtransactions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currenttxhash(from._internal_currenttxhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_previousledger(from._internal_previousledger());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.proposeseq_ = from._impl_.proposeseq_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.closetime_ = from._impl_.closetime_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.checkedsignature_ = from._impl_.checkedsignature_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.hops_ = from._impl_.hops_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_ledgerseq(from._internal_ledgerseq());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMProposeSet::CopyFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProposeSet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMProposeSet::InternalSwap(TMProposeSet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.addedtransactions_.InternalSwap(&other->_impl_.addedtransactions_);
  _impl_.removedtransactions_.InternalSwap(&other->_impl_.removedtransactions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currenttxhash_, lhs_arena,
      &other->_impl_.currenttxhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodepubkey_, lhs_arena,
      &other->_impl_.nodepubkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.previousledger_, lhs_arena,
      &other->_impl_.previousledger_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMProposeSet, _impl_.ledgerseq_)
      + sizeof(TMProposeSet::_impl_.ledgerseq_)
      - PROTOBUF_FIELD_OFFSET(TMProposeSet, _impl_.proposeseq_)>(
          reinterpret_cast<char*>(&_impl_.proposeseq_),
          reinterpret_cast<char*>(&other->_impl_.proposeseq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProposeSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[15]);
}

// ===================================================================

class TMHaveTransactionSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TMHaveTransactionSet>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMHaveTransactionSet::TMHaveTransactionSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMHaveTransactionSet)
}
TMHaveTransactionSet::TMHaveTransactionSet(const TMHaveTransactionSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMHaveTransactionSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactionSet)
}

inline void TMHaveTransactionSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.status_){1}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMHaveTransactionSet::~TMHaveTransactionSet() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactionSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMHaveTransactionSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
}

void TMHaveTransactionSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMHaveTransactionSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactionSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    _impl_.status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMHaveTransactionSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .protocol.TxSetStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TxSetStatus_IsValid(val))) {
            _internal_set_status(static_cast<::protocol::TxSetStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMHaveTransactionSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactionSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactionSet)
  return target;
}

size_t TMHaveTransactionSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (_internal_has_hash()) {
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  if (_internal_has_status()) {
    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t TMHaveTransactionSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());

    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMHaveTransactionSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMHaveTransactionSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMHaveTransactionSet::GetClassData() const { return &_class_data_; }


void TMHaveTransactionSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMHaveTransactionSet*>(&to_msg);
  auto& from = static_cast<const TMHaveTransactionSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMHaveTransactionSet::CopyFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactionSet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMHaveTransactionSet::InternalSwap(TMHaveTransactionSet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMHaveTransactionSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[16]);
}

// ===================================================================

class TMValidatorList::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidatorList>()._impl_._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TMValidatorList::TMValidatorList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidatorList)
}
TMValidatorList::TMValidatorList(const TMValidatorList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMValidatorList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.blob_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manifest()) {
    _this->_impl_.manifest_.Set(from._internal_manifest(), 
      _this->GetArenaForAllocation());
  }
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_blob()) {
    _this->_impl_.blob_.Set(from._internal_blob(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorList)
}

inline void TMValidatorList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.blob_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.version_){0u}
  };
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMValidatorList::~TMValidatorList() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMValidatorList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.manifest_.Destroy();
  _impl_.blob_.Destroy();
  _impl_.signature_.Destroy();
}

void TMValidatorList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMValidatorList::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.blob_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidatorList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manifest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_blob();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMValidatorList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  // required uint32 version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorList)
  return target;
}

size_t TMValidatorList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (_internal_has_manifest()) {
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  if (_internal_has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_version()) {
    // required uint32 version = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return total_size;
}
size_t TMValidatorList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());

    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required uint32 version = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMValidatorList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMValidatorList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMValidatorList::GetClassData() const { return &_class_data_; }


void TMValidatorList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMValidatorList*>(&to_msg);
  auto& from = static_cast<const TMValidatorList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_blob(from._internal_blob());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMValidatorList::CopyFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMValidatorList::InternalSwap(TMValidatorList* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manifest_, lhs_arena,
      &other->_impl_.manifest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.blob_, lhs_arena,
      &other->_impl_.blob_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[17]);
}

// ===================================================================

class ValidatorBlobInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ValidatorBlobInfo>()._impl_._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

ValidatorBlobInfo::ValidatorBlobInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.ValidatorBlobInfo)
}
ValidatorBlobInfo::ValidatorBlobInfo(const ValidatorBlobInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ValidatorBlobInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.blob_){}
    , decltype(_impl_.signature_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manifest()) {
    _this->_impl_.manifest_.Set(from._internal_manifest(), 
      _this->GetArenaForAllocation());
  }
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_blob()) {
    _this->_impl_.blob_.Set(from._internal_blob(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.ValidatorBlobInfo)
}

inline void ValidatorBlobInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.blob_){}
    , decltype(_impl_.signature_){}
  };
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ValidatorBlobInfo::~ValidatorBlobInfo() {
  // @@protoc_insertion_point(destructor:protocol.ValidatorBlobInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValidatorBlobInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.manifest_.Destroy();
  _impl_.blob_.Destroy();
  _impl_.signature_.Destroy();
}

void ValidatorBlobInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ValidatorBlobInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.ValidatorBlobInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.blob_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ValidatorBlobInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manifest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_blob();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValidatorBlobInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.ValidatorBlobInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.ValidatorBlobInfo)
  return target;
}

size_t ValidatorBlobInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.ValidatorBlobInfo)
  size_t total_size = 0;

  if (_internal_has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return total_size;
}
size_t ValidatorBlobInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.ValidatorBlobInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes manifest = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ValidatorBlobInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ValidatorBlobInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ValidatorBlobInfo::GetClassData() const { return &_class_data_; }


void ValidatorBlobInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ValidatorBlobInfo*>(&to_msg);
  auto& from = static_cast<const ValidatorBlobInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.ValidatorBlobInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_blob(from._internal_blob());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_signature(from._internal_signature());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ValidatorBlobInfo::CopyFrom(const ValidatorBlobInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.ValidatorBlobInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorBlobInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ValidatorBlobInfo::InternalSwap(ValidatorBlobInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manifest_, lhs_arena,
      &other->_impl_.manifest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.blob_, lhs_arena,
      &other->_impl_.blob_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ValidatorBlobInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[18]);
}

// ===================================================================

class TMValidatorListCollection::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidatorListCollection>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMValidatorListCollection::TMValidatorListCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidatorListCollection)
}
TMValidatorListCollection::TMValidatorListCollection(const TMValidatorListCollection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMValidatorListCollection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blobs_){from._impl_.blobs_}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manifest()) {
    _this->_impl_.manifest_.Set(from._internal_manifest(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorListCollection)
}

inline void TMValidatorListCollection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blobs_){arena}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.version_){0u}
  };
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMValidatorListCollection::~TMValidatorListCollection() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorListCollection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMValidatorListCollection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blobs_.~RepeatedPtrField();
  _impl_.manifest_.Destroy();
}

void TMValidatorListCollection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMValidatorListCollection::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorListCollection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blobs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.manifest_.ClearNonDefaultToEmpty();
  }
  _impl_.version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidatorListCollection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes manifest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_manifest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.ValidatorBlobInfo blobs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMValidatorListCollection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorListCollection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // required bytes manifest = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_manifest(), target);
  }

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blobs_size()); i < n; i++) {
    const auto& repfield = this->_internal_blobs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorListCollection)
  return target;
}

size_t TMValidatorListCollection::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorListCollection)
  size_t total_size = 0;

  if (_internal_has_manifest()) {
    // required bytes manifest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  if (_internal_has_version()) {
    // required uint32 version = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return total_size;
}
size_t TMValidatorListCollection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorListCollection)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes manifest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());

    // required uint32 version = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  total_size += 1UL * this->_internal_blobs_size();
  for (const auto& msg : this->_impl_.blobs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMValidatorListCollection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMValidatorListCollection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMValidatorListCollection::GetClassData() const { return &_class_data_; }


void TMValidatorListCollection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMValidatorListCollection*>(&to_msg);
  auto& from = static_cast<const TMValidatorListCollection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorListCollection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.blobs_.MergeFrom(from._impl_.blobs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMValidatorListCollection::CopyFrom(const TMValidatorListCollection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorListCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorListCollection::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.blobs_))
    return false;
  return true;
}

void TMValidatorListCollection::InternalSwap(TMValidatorListCollection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.blobs_.InternalSwap(&other->_impl_.blobs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manifest_, lhs_arena,
      &other->_impl_.manifest_, rhs_arena
  );
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorListCollection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[19]);
}

// ===================================================================

class TMValidation::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidation>()._impl_._has_bits_);
  static void set_has_validation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMValidation::TMValidation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidation)
}
TMValidation::TMValidation(const TMValidation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMValidation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.validation_){}
    , decltype(_impl_.checkedsignature_){}
    , decltype(_impl_.hops_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.validation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_validation()) {
    _this->_impl_.validation_.Set(from._internal_validation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.checkedsignature_, &from._impl_.checkedsignature_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hops_) -
    reinterpret_cast<char*>(&_impl_.checkedsignature_)) + sizeof(_impl_.hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidation)
}

inline void TMValidation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.validation_){}
    , decltype(_impl_.checkedsignature_){false}
    , decltype(_impl_.hops_){0u}
  };
  _impl_.validation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMValidation::~TMValidation() {
  // @@protoc_insertion_point(destructor:protocol.TMValidation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMValidation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.validation_.Destroy();
}

void TMValidation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMValidation::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.validation_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.checkedsignature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hops_) -
        reinterpret_cast<char*>(&_impl_.checkedsignature_)) + sizeof(_impl_.hops_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes validation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_validation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool checkedSignature = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_checkedsignature(&has_bits);
          _impl_.checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hops = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hops(&has_bits);
          _impl_.hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMValidation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_validation(), target);
  }

  // optional bool checkedSignature = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_checkedsignature(), target);
  }

  // optional uint32 hops = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidation)
  return target;
}

size_t TMValidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidation)
  size_t total_size = 0;

  // required bytes validation = 1;
  if (_internal_has_validation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validation());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool checkedSignature = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hops());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMValidation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMValidation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMValidation::GetClassData() const { return &_class_data_; }


void TMValidation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMValidation*>(&to_msg);
  auto& from = static_cast<const TMValidation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_validation(from._internal_validation());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.checkedsignature_ = from._impl_.checkedsignature_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hops_ = from._impl_.hops_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMValidation::CopyFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMValidation::InternalSwap(TMValidation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.validation_, lhs_arena,
      &other->_impl_.validation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMValidation, _impl_.hops_)
      + sizeof(TMValidation::_impl_.hops_)
      - PROTOBUF_FIELD_OFFSET(TMValidation, _impl_.checkedsignature_)>(
          reinterpret_cast<char*>(&_impl_.checkedsignature_),
          reinterpret_cast<char*>(&other->_impl_.checkedsignature_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[20]);
}

// ===================================================================

class TMEndpoints_TMEndpointv2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoints_TMEndpointv2>()._impl_._has_bits_);
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoints.TMEndpointv2)
}
TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(const TMEndpoints_TMEndpointv2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMEndpoints_TMEndpointv2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoint_){}
    , decltype(_impl_.hops_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.endpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoint()) {
    _this->_impl_.endpoint_.Set(from._internal_endpoint(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.hops_ = from._impl_.hops_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints.TMEndpointv2)
}

inline void TMEndpoints_TMEndpointv2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoint_){}
    , decltype(_impl_.hops_){0u}
  };
  _impl_.endpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMEndpoints_TMEndpointv2::~TMEndpoints_TMEndpointv2() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints.TMEndpointv2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMEndpoints_TMEndpointv2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.endpoint_.Destroy();
}

void TMEndpoints_TMEndpointv2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMEndpoints_TMEndpointv2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints.TMEndpointv2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.endpoint_.ClearNonDefaultToEmpty();
  }
  _impl_.hops_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoints_TMEndpointv2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string endpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "protocol.TMEndpoints.TMEndpointv2.endpoint");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 hops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hops(&has_bits);
          _impl_.hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMEndpoints_TMEndpointv2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints.TMEndpointv2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string endpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMEndpoints.TMEndpointv2.endpoint");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint(), target);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints.TMEndpointv2)
  return target;
}

size_t TMEndpoints_TMEndpointv2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (_internal_has_endpoint()) {
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_endpoint());
  }

  if (_internal_has_hops()) {
    // required uint32 hops = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hops());
  }

  return total_size;
}
size_t TMEndpoints_TMEndpointv2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_endpoint());

    // required uint32 hops = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hops());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMEndpoints_TMEndpointv2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMEndpoints_TMEndpointv2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMEndpoints_TMEndpointv2::GetClassData() const { return &_class_data_; }


void TMEndpoints_TMEndpointv2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMEndpoints_TMEndpointv2*>(&to_msg);
  auto& from = static_cast<const TMEndpoints_TMEndpointv2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hops_ = from._impl_.hops_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMEndpoints_TMEndpointv2::CopyFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints_TMEndpointv2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMEndpoints_TMEndpointv2::InternalSwap(TMEndpoints_TMEndpointv2* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.endpoint_, lhs_arena,
      &other->_impl_.endpoint_, rhs_arena
  );
  swap(_impl_.hops_, other->_impl_.hops_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints_TMEndpointv2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[21]);
}

// ===================================================================

class TMEndpoints::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoints>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMEndpoints::TMEndpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoints)
}
TMEndpoints::TMEndpoints(const TMEndpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMEndpoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoints_v2_){from._impl_.endpoints_v2_}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints)
}

inline void TMEndpoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoints_v2_){arena}
    , decltype(_impl_.version_){0u}
  };
}

TMEndpoints::~TMEndpoints() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMEndpoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.endpoints_v2_.~RepeatedPtrField();
}

void TMEndpoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMEndpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.endpoints_v2_.Clear();
  _impl_.version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_endpoints_v2(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMEndpoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_endpoints_v2_size()); i < n; i++) {
    const auto& repfield = this->_internal_endpoints_v2(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints)
  return target;
}

size_t TMEndpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints)
  size_t total_size = 0;

  // required uint32 version = 1;
  if (_internal_has_version()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  total_size += 1UL * this->_internal_endpoints_v2_size();
  for (const auto& msg : this->_impl_.endpoints_v2_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMEndpoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMEndpoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMEndpoints::GetClassData() const { return &_class_data_; }


void TMEndpoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMEndpoints*>(&to_msg);
  auto& from = static_cast<const TMEndpoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.endpoints_v2_.MergeFrom(from._impl_.endpoints_v2_);
  if (from._internal_has_version()) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMEndpoints::CopyFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.endpoints_v2_))
    return false;
  return true;
}

void TMEndpoints::InternalSwap(TMEndpoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.endpoints_v2_.InternalSwap(&other->_impl_.endpoints_v2_);
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[22]);
}

// ===================================================================

class TMIndexedObject::_Internal {
 public:
  using HasBits = decltype(std::declval<TMIndexedObject>()._impl_._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TMIndexedObject::TMIndexedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMIndexedObject)
}
TMIndexedObject::TMIndexedObject(const TMIndexedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMIndexedObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.nodeid_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.ledgerseq_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodeid()) {
    _this->_impl_.nodeid_.Set(from._internal_nodeid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.index_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.index_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_index()) {
    _this->_impl_.index_.Set(from._internal_index(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.ledgerseq_ = from._impl_.ledgerseq_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMIndexedObject)
}

inline void TMIndexedObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.nodeid_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.ledgerseq_){0u}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.index_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.index_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMIndexedObject::~TMIndexedObject() {
  // @@protoc_insertion_point(destructor:protocol.TMIndexedObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMIndexedObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
  _impl_.nodeid_.Destroy();
  _impl_.index_.Destroy();
  _impl_.data_.Destroy();
}

void TMIndexedObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMIndexedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIndexedObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.nodeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.index_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.ledgerseq_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMIndexedObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodeID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nodeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_index();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ledgerseq(&has_bits);
          _impl_.ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMIndexedObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIndexedObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodeid(), target);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_index(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ledgerseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIndexedObject)
  return target;
}

size_t TMIndexedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIndexedObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional bytes nodeID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodeid());
    }

    // optional bytes index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_index());
    }

    // optional bytes data = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 ledgerSeq = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledgerseq());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMIndexedObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMIndexedObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMIndexedObject::GetClassData() const { return &_class_data_; }


void TMIndexedObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMIndexedObject*>(&to_msg);
  auto& from = static_cast<const TMIndexedObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_nodeid(from._internal_nodeid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_index(from._internal_index());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ledgerseq_ = from._impl_.ledgerseq_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMIndexedObject::CopyFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIndexedObject::IsInitialized() const {
  return true;
}

void TMIndexedObject::InternalSwap(TMIndexedObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodeid_, lhs_arena,
      &other->_impl_.nodeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.index_, lhs_arena,
      &other->_impl_.index_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.ledgerseq_, other->_impl_.ledgerseq_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMIndexedObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[23]);
}

// ===================================================================

class TMGetObjectByHash::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetObjectByHash>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fat(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000a) ^ 0x0000000a) != 0;
  }
};

TMGetObjectByHash::TMGetObjectByHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetObjectByHash)
}
TMGetObjectByHash::TMGetObjectByHash(const TMGetObjectByHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMGetObjectByHash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){from._impl_.objects_}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.seq_){}
    , decltype(_impl_.query_){}
    , decltype(_impl_.fat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fat_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.fat_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetObjectByHash)
}

inline void TMGetObjectByHash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){arena}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.seq_){0u}
    , decltype(_impl_.query_){false}
    , decltype(_impl_.fat_){false}
  };
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMGetObjectByHash::~TMGetObjectByHash() {
  // @@protoc_insertion_point(destructor:protocol.TMGetObjectByHash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMGetObjectByHash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
  _impl_.ledgerhash_.Destroy();
}

void TMGetObjectByHash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMGetObjectByHash::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetObjectByHash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fat_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.fat_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetObjectByHash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMGetObjectByHash_ObjectType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMGetObjectByHash_ObjectType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bool query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_query(&has_bits);
          _impl_.query_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seq(&has_bits);
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool fat = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_fat(&has_bits);
          _impl_.fat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMIndexedObject objects = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMGetObjectByHash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetObjectByHash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_query(), target);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerhash(), target);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_fat(), target);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetObjectByHash)
  return target;
}

size_t TMGetObjectByHash::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (_internal_has_type()) {
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_query()) {
    // required bool query = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMGetObjectByHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

    // required bool query = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMIndexedObject objects = 6;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes ledgerHash = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq());
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMGetObjectByHash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMGetObjectByHash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMGetObjectByHash::GetClassData() const { return &_class_data_; }


void TMGetObjectByHash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMGetObjectByHash*>(&to_msg);
  auto& from = static_cast<const TMGetObjectByHash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.seq_ = from._impl_.seq_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.query_ = from._impl_.query_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.fat_ = from._impl_.fat_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMGetObjectByHash::CopyFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetObjectByHash::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMGetObjectByHash::InternalSwap(TMGetObjectByHash* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetObjectByHash, _impl_.fat_)
      + sizeof(TMGetObjectByHash::_impl_.fat_)
      - PROTOBUF_FIELD_OFFSET(TMGetObjectByHash, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetObjectByHash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[24]);
}

// ===================================================================

class TMLedgerNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLedgerNode>()._impl_._has_bits_);
  static void set_has_nodedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMLedgerNode::TMLedgerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLedgerNode)
}
TMLedgerNode::TMLedgerNode(const TMLedgerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMLedgerNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodedata_){}
    , decltype(_impl_.nodeid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nodedata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodedata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodedata()) {
    _this->_impl_.nodedata_.Set(from._internal_nodedata(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodeid()) {
    _this->_impl_.nodeid_.Set(from._internal_nodeid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerNode)
}

inline void TMLedgerNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodedata_){}
    , decltype(_impl_.nodeid_){}
  };
  _impl_.nodedata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodedata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMLedgerNode::~TMLedgerNode() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMLedgerNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodedata_.Destroy();
  _impl_.nodeid_.Destroy();
}

void TMLedgerNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMLedgerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.nodedata_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.nodeid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLedgerNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes nodedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nodedata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodeid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nodeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMLedgerNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nodedata(), target);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodeid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerNode)
  return target;
}

size_t TMLedgerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerNode)
  size_t total_size = 0;

  // required bytes nodedata = 1;
  if (_internal_has_nodedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodedata());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes nodeid = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodeid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMLedgerNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMLedgerNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMLedgerNode::GetClassData() const { return &_class_data_; }


void TMLedgerNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMLedgerNode*>(&to_msg);
  auto& from = static_cast<const TMLedgerNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nodedata(from._internal_nodedata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_nodeid(from._internal_nodeid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMLedgerNode::CopyFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMLedgerNode::InternalSwap(TMLedgerNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodedata_, lhs_arena,
      &other->_impl_.nodedata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodeid_, lhs_arena,
      &other->_impl_.nodeid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[25]);
}

// ===================================================================

class TMGetLedger::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetLedger>()._impl_._has_bits_);
  static void set_has_itype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ltype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_querytype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_querydepth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

TMGetLedger::TMGetLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetLedger)
}
TMGetLedger::TMGetLedger(const TMGetLedger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMGetLedger* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodeids_){from._impl_.nodeids_}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.itype_){}
    , decltype(_impl_.ltype_){}
    , decltype(_impl_.ledgerseq_){}
    , decltype(_impl_.querytype_){}
    , decltype(_impl_.requestcookie_){}
    , decltype(_impl_.querydepth_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.itype_, &from._impl_.itype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.querydepth_) -
    reinterpret_cast<char*>(&_impl_.itype_)) + sizeof(_impl_.querydepth_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetLedger)
}

inline void TMGetLedger::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodeids_){arena}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.itype_){0}
    , decltype(_impl_.ltype_){0}
    , decltype(_impl_.ledgerseq_){0u}
    , decltype(_impl_.querytype_){0}
    , decltype(_impl_.requestcookie_){uint64_t{0u}}
    , decltype(_impl_.querydepth_){0u}
  };
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMGetLedger::~TMGetLedger() {
  // @@protoc_insertion_point(destructor:protocol.TMGetLedger)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMGetLedger::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodeids_.~RepeatedPtrField();
  _impl_.ledgerhash_.Destroy();
}

void TMGetLedger::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMGetLedger::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetLedger)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodeids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.itype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.querydepth_) -
        reinterpret_cast<char*>(&_impl_.itype_)) + sizeof(_impl_.querydepth_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetLedger::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            _internal_set_itype(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .protocol.TMLedgerType ltype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerType_IsValid(val))) {
            _internal_set_ltype(static_cast<::protocol::TMLedgerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ledgerseq(&has_bits);
          _impl_.ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes nodeIDs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodeids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 requestCookie = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_requestcookie(&has_bits);
          _impl_.requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .protocol.TMQueryType queryType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMQueryType_IsValid(val))) {
            _internal_set_querytype(static_cast<::protocol::TMQueryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 queryDepth = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_querydepth(&has_bits);
          _impl_.querydepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMGetLedger::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetLedger)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_itype(), target);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_ltype(), target);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ledgerhash(), target);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ledgerseq(), target);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->_internal_nodeids_size(); i < n; i++) {
    const auto& s = this->_internal_nodeids(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_requestcookie(), target);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_querytype(), target);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_querydepth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetLedger)
  return target;
}

size_t TMGetLedger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetLedger)
  size_t total_size = 0;

  // required .protocol.TMLedgerInfoType itype = 1;
  if (_internal_has_itype()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_itype());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes nodeIDs = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.nodeids_.size());
  for (int i = 0, n = _impl_.nodeids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.nodeids_.Get(i));
  }

  // optional bytes ledgerHash = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional .protocol.TMLedgerType ltype = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ltype());
    }

    // optional uint32 ledgerSeq = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledgerseq());
    }

    // optional .protocol.TMQueryType queryType = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_querytype());
    }

    // optional uint64 requestCookie = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_requestcookie());
    }

    // optional uint32 queryDepth = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_querydepth());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMGetLedger::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMGetLedger::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMGetLedger::GetClassData() const { return &_class_data_; }


void TMGetLedger::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMGetLedger*>(&to_msg);
  auto& from = static_cast<const TMGetLedger&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodeids_.MergeFrom(from._impl_.nodeids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.itype_ = from._impl_.itype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ltype_ = from._impl_.ltype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ledgerseq_ = from._impl_.ledgerseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.querytype_ = from._impl_.querytype_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.requestcookie_ = from._impl_.requestcookie_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.querydepth_ = from._impl_.querydepth_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMGetLedger::CopyFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetLedger::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMGetLedger::InternalSwap(TMGetLedger* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nodeids_.InternalSwap(&other->_impl_.nodeids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetLedger, _impl_.querydepth_)
      + sizeof(TMGetLedger::_impl_.querydepth_)
      - PROTOBUF_FIELD_OFFSET(TMGetLedger, _impl_.itype_)>(
          reinterpret_cast<char*>(&_impl_.itype_),
          reinterpret_cast<char*>(&other->_impl_.itype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetLedger::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[26]);
}

// ===================================================================

class TMLedgerData::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLedgerData>()._impl_._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TMLedgerData::TMLedgerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLedgerData)
}
TMLedgerData::TMLedgerData(const TMLedgerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMLedgerData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerseq_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.requestcookie_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ledgerseq_, &from._impl_.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_) -
    reinterpret_cast<char*>(&_impl_.ledgerseq_)) + sizeof(_impl_.error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerData)
}

inline void TMLedgerData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodes_){arena}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerseq_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.requestcookie_){0u}
    , decltype(_impl_.error_){1}
  };
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMLedgerData::~TMLedgerData() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMLedgerData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
  _impl_.ledgerhash_.Destroy();
}

void TMLedgerData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMLedgerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.requestcookie_) -
        reinterpret_cast<char*>(&_impl_.ledgerseq_)) + sizeof(_impl_.requestcookie_));
    _impl_.error_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLedgerData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ledgerSeq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ledgerseq(&has_bits);
          _impl_.ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .protocol.TMLedgerInfoType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 requestCookie = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_requestcookie(&has_bits);
          _impl_.requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMLedgerData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ledgerseq(), target);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_requestcookie(), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerData)
  return target;
}

size_t TMLedgerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_ledgerseq()) {
    // required uint32 ledgerSeq = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledgerseq());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMLedgerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required uint32 ledgerSeq = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledgerseq());

    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLedgerNode nodes = 4;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional uint32 requestCookie = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_requestcookie());
    }

    // optional .protocol.TMReplyError error = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMLedgerData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMLedgerData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMLedgerData::GetClassData() const { return &_class_data_; }


void TMLedgerData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMLedgerData*>(&to_msg);
  auto& from = static_cast<const TMLedgerData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ledgerseq_ = from._impl_.ledgerseq_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.requestcookie_ = from._impl_.requestcookie_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMLedgerData::CopyFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.nodes_))
    return false;
  return true;
}

void TMLedgerData::InternalSwap(TMLedgerData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMLedgerData, _impl_.requestcookie_)
      + sizeof(TMLedgerData::_impl_.requestcookie_)
      - PROTOBUF_FIELD_OFFSET(TMLedgerData, _impl_.ledgerseq_)>(
          reinterpret_cast<char*>(&_impl_.ledgerseq_),
          reinterpret_cast<char*>(&other->_impl_.ledgerseq_));
  swap(_impl_.error_, other->_impl_.error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[27]);
}

// ===================================================================

class TMPing::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPing>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pingtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nettime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPing::TMPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPing)
}
TMPing::TMPing(const TMPing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMPing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.seq_){}
    , decltype(_impl_.pingtime_){}
    , decltype(_impl_.nettime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nettime_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.nettime_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPing)
}

inline void TMPing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.seq_){0u}
    , decltype(_impl_.pingtime_){uint64_t{0u}}
    , decltype(_impl_.nettime_){uint64_t{0u}}
  };
}

TMPing::~TMPing() {
  // @@protoc_insertion_point(destructor:protocol.TMPing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMPing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TMPing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMPing::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nettime_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.nettime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .protocol.TMPing.pingType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMPing_pingType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMPing_pingType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seq(&has_bits);
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pingTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pingtime(&has_bits);
          _impl_.pingtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 netTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nettime(&has_bits);
          _impl_.nettime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMPing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_seq(), target);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pingtime(), target);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_nettime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPing)
  return target;
}

size_t TMPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPing)
  size_t total_size = 0;

  // required .protocol.TMPing.pingType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint32 seq = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq());
    }

    // optional uint64 pingTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pingtime());
    }

    // optional uint64 netTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nettime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMPing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMPing::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMPing::GetClassData() const { return &_class_data_; }


void TMPing::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMPing*>(&to_msg);
  auto& from = static_cast<const TMPing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.seq_ = from._impl_.seq_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pingtime_ = from._impl_.pingtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nettime_ = from._impl_.nettime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMPing::CopyFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPing::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMPing::InternalSwap(TMPing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMPing, _impl_.nettime_)
      + sizeof(TMPing::_impl_.nettime_)
      - PROTOBUF_FIELD_OFFSET(TMPing, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[28]);
}

// ===================================================================

class TMSquelch::_Internal {
 public:
  using HasBits = decltype(std::declval<TMSquelch>()._impl_._has_bits_);
  static void set_has_squelch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validatorpubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_squelchduration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMSquelch::TMSquelch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMSquelch)
}
TMSquelch::TMSquelch(const TMSquelch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMSquelch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.validatorpubkey_){}
    , decltype(_impl_.squelch_){}
    , decltype(_impl_.squelchduration_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.validatorpubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validatorpubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_validatorpubkey()) {
    _this->_impl_.validatorpubkey_.Set(from._internal_validatorpubkey(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.squelch_, &from._impl_.squelch_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.squelchduration_) -
    reinterpret_cast<char*>(&_impl_.squelch_)) + sizeof(_impl_.squelchduration_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMSquelch)
}

inline void TMSquelch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.validatorpubkey_){}
    , decltype(_impl_.squelch_){false}
    , decltype(_impl_.squelchduration_){0u}
  };
  _impl_.validatorpubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validatorpubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMSquelch::~TMSquelch() {
  // @@protoc_insertion_point(destructor:protocol.TMSquelch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMSquelch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.validatorpubkey_.Destroy();
}

void TMSquelch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMSquelch::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMSquelch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.validatorpubkey_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.squelch_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.squelchduration_) -
        reinterpret_cast<char*>(&_impl_.squelch_)) + sizeof(_impl_.squelchduration_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMSquelch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool squelch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_squelch(&has_bits);
          _impl_.squelch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes validatorPubKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_validatorpubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 squelchDuration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_squelchduration(&has_bits);
          _impl_.squelchduration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMSquelch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMSquelch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool squelch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_squelch(), target);
  }

  // required bytes validatorPubKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_validatorpubkey(), target);
  }

  // optional uint32 squelchDuration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_squelchduration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMSquelch)
  return target;
}

size_t TMSquelch::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMSquelch)
  size_t total_size = 0;

  if (_internal_has_validatorpubkey()) {
    // required bytes validatorPubKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validatorpubkey());
  }

  if (_internal_has_squelch()) {
    // required bool squelch = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMSquelch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMSquelch)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes validatorPubKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validatorpubkey());

    // required bool squelch = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 squelchDuration = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_squelchduration());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMSquelch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMSquelch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMSquelch::GetClassData() const { return &_class_data_; }


void TMSquelch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMSquelch*>(&to_msg);
  auto& from = static_cast<const TMSquelch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMSquelch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_validatorpubkey(from._internal_validatorpubkey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.squelch_ = from._impl_.squelch_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.squelchduration_ = from._impl_.squelchduration_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMSquelch::CopyFrom(const TMSquelch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMSquelch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMSquelch::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMSquelch::InternalSwap(TMSquelch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.validatorpubkey_, lhs_arena,
      &other->_impl_.validatorpubkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMSquelch, _impl_.squelchduration_)
      + sizeof(TMSquelch::_impl_.squelchduration_)
      - PROTOBUF_FIELD_OFFSET(TMSquelch, _impl_.squelch_)>(
          reinterpret_cast<char*>(&_impl_.squelch_),
          reinterpret_cast<char*>(&other->_impl_.squelch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMSquelch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[29]);
}

// ===================================================================

class TMProofPathRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProofPathRequest>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TMProofPathRequest::TMProofPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProofPathRequest)
}
TMProofPathRequest::TMProofPathRequest(const TMProofPathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMProofPathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofPathRequest)
}

inline void TMProofPathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.type_){1}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMProofPathRequest::~TMProofPathRequest() {
  // @@protoc_insertion_point(destructor:protocol.TMProofPathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMProofPathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.ledgerhash_.Destroy();
}

void TMProofPathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMProofPathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofPathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ledgerhash_.ClearNonDefaultToEmpty();
    }
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProofPathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes ledgerHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .protocol.TMLedgerMapType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerMapType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerMapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMProofPathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofPathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledgerhash(), target);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofPathRequest)
  return target;
}

size_t TMProofPathRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProofPathRequest)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMProofPathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofPathRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());

    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMProofPathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMProofPathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMProofPathRequest::GetClassData() const { return &_class_data_; }


void TMProofPathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMProofPathRequest*>(&to_msg);
  auto& from = static_cast<const TMProofPathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofPathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMProofPathRequest::CopyFrom(const TMProofPathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofPathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofPathRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMProofPathRequest::InternalSwap(TMProofPathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProofPathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[30]);
}

// ===================================================================

class TMProofPathResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProofPathResponse>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerheader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

TMProofPathResponse::TMProofPathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProofPathResponse)
}
TMProofPathResponse::TMProofPathResponse(const TMProofPathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMProofPathResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){from._impl_.path_}
    , decltype(_impl_.key_){}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerheader_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ledgerheader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerheader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerheader()) {
    _this->_impl_.ledgerheader_.Set(from._internal_ledgerheader(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofPathResponse)
}

inline void TMProofPathResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){arena}
    , decltype(_impl_.key_){}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerheader_){}
    , decltype(_impl_.type_){1}
    , decltype(_impl_.error_){1}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ledgerheader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerheader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMProofPathResponse::~TMProofPathResponse() {
  // @@protoc_insertion_point(destructor:protocol.TMProofPathResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMProofPathResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.~RepeatedPtrField();
  _impl_.key_.Destroy();
  _impl_.ledgerhash_.Destroy();
  _impl_.ledgerheader_.Destroy();
}

void TMProofPathResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMProofPathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofPathResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.ledgerheader_.ClearNonDefaultToEmpty();
    }
    _impl_.type_ = 1;
    _impl_.error_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProofPathResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes ledgerHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .protocol.TMLedgerMapType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerMapType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerMapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes ledgerHeader = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ledgerheader();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_path();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMProofPathResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofPathResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledgerhash(), target);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional bytes ledgerHeader = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerheader(), target);
  }

  // repeated bytes path = 5;
  for (int i = 0, n = this->_internal_path_size(); i < n; i++) {
    const auto& s = this->_internal_path(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofPathResponse)
  return target;
}

size_t TMProofPathResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProofPathResponse)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMProofPathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofPathResponse)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());

    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes path = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.path_.size());
  for (int i = 0, n = _impl_.path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.path_.Get(i));
  }

  // optional bytes ledgerHeader = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerheader());
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMProofPathResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMProofPathResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMProofPathResponse::GetClassData() const { return &_class_data_; }


void TMProofPathResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMProofPathResponse*>(&to_msg);
  auto& from = static_cast<const TMProofPathResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofPathResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.path_.MergeFrom(from._impl_.path_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_ledgerheader(from._internal_ledgerheader());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMProofPathResponse::CopyFrom(const TMProofPathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofPathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofPathResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMProofPathResponse::InternalSwap(TMProofPathResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerheader_, lhs_arena,
      &other->_impl_.ledgerheader_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_.error_, other->_impl_.error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProofPathResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[31]);
}

// ===================================================================

class TMReplayDeltaRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMReplayDeltaRequest>()._impl_._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMReplayDeltaRequest::TMReplayDeltaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMReplayDeltaRequest)
}
TMReplayDeltaRequest::TMReplayDeltaRequest(const TMReplayDeltaRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMReplayDeltaRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ledgerhash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMReplayDeltaRequest)
}

inline void TMReplayDeltaRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ledgerhash_){}
  };
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMReplayDeltaRequest::~TMReplayDeltaRequest() {
  // @@protoc_insertion_point(destructor:protocol.TMReplayDeltaRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMReplayDeltaRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ledgerhash_.Destroy();
}

void TMReplayDeltaRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMReplayDeltaRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMReplayDeltaRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ledgerhash_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMReplayDeltaRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMReplayDeltaRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMReplayDeltaRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMReplayDeltaRequest)
  return target;
}

size_t TMReplayDeltaRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMReplayDeltaRequest)
  size_t total_size = 0;

  // required bytes ledgerHash = 1;
  if (_internal_has_ledgerhash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMReplayDeltaRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMReplayDeltaRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMReplayDeltaRequest::GetClassData() const { return &_class_data_; }


void TMReplayDeltaRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMReplayDeltaRequest*>(&to_msg);
  auto& from = static_cast<const TMReplayDeltaRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMReplayDeltaRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ledgerhash()) {
    _this->_internal_set_ledgerhash(from._internal_ledgerhash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMReplayDeltaRequest::CopyFrom(const TMReplayDeltaRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMReplayDeltaRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMReplayDeltaRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMReplayDeltaRequest::InternalSwap(TMReplayDeltaRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TMReplayDeltaRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[32]);
}

// ===================================================================

class TMReplayDeltaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<TMReplayDeltaResponse>()._impl_._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerheader(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMReplayDeltaResponse::TMReplayDeltaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMReplayDeltaResponse)
}
TMReplayDeltaResponse::TMReplayDeltaResponse(const TMReplayDeltaResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMReplayDeltaResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transaction_){from._impl_.transaction_}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerheader_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerhash()) {
    _this->_impl_.ledgerhash_.Set(from._internal_ledgerhash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ledgerheader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerheader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ledgerheader()) {
    _this->_impl_.ledgerheader_.Set(from._internal_ledgerheader(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_ = from._impl_.error_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMReplayDeltaResponse)
}

inline void TMReplayDeltaResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transaction_){arena}
    , decltype(_impl_.ledgerhash_){}
    , decltype(_impl_.ledgerheader_){}
    , decltype(_impl_.error_){1}
  };
  _impl_.ledgerhash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerhash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ledgerheader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledgerheader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMReplayDeltaResponse::~TMReplayDeltaResponse() {
  // @@protoc_insertion_point(destructor:protocol.TMReplayDeltaResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMReplayDeltaResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transaction_.~RepeatedPtrField();
  _impl_.ledgerhash_.Destroy();
  _impl_.ledgerheader_.Destroy();
}

void TMReplayDeltaResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMReplayDeltaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMReplayDeltaResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transaction_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ledgerheader_.ClearNonDefaultToEmpty();
    }
    _impl_.error_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMReplayDeltaResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ledgerHeader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ledgerheader();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transaction();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMReplayDeltaResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMReplayDeltaResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  // optional bytes ledgerHeader = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledgerheader(), target);
  }

  // repeated bytes transaction = 3;
  for (int i = 0, n = this->_internal_transaction_size(); i < n; i++) {
    const auto& s = this->_internal_transaction(i);
    target = stream->WriteBytes(3, s, target);
  }

  // optional .protocol.TMReplyError error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMReplayDeltaResponse)
  return target;
}

size_t TMReplayDeltaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMReplayDeltaResponse)
  size_t total_size = 0;

  // required bytes ledgerHash = 1;
  if (_internal_has_ledgerhash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes transaction = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.transaction_.size());
  for (int i = 0, n = _impl_.transaction_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.transaction_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bytes ledgerHeader = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerheader());
    }

    // optional .protocol.TMReplyError error = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMReplayDeltaResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMReplayDeltaResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMReplayDeltaResponse::GetClassData() const { return &_class_data_; }


void TMReplayDeltaResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMReplayDeltaResponse*>(&to_msg);
  auto& from = static_cast<const TMReplayDeltaResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMReplayDeltaResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transaction_.MergeFrom(from._impl_.transaction_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ledgerheader(from._internal_ledgerheader());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMReplayDeltaResponse::CopyFrom(const TMReplayDeltaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMReplayDeltaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMReplayDeltaResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMReplayDeltaResponse::InternalSwap(TMReplayDeltaResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.transaction_.InternalSwap(&other->_impl_.transaction_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerhash_, lhs_arena,
      &other->_impl_.ledgerhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledgerheader_, lhs_arena,
      &other->_impl_.ledgerheader_, rhs_arena
  );
  swap(_impl_.error_, other->_impl_.error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMReplayDeltaResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[33]);
}

// ===================================================================

class TMHaveTransactions::_Internal {
 public:
};

TMHaveTransactions::TMHaveTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.TMHaveTransactions)
}
TMHaveTransactions::TMHaveTransactions(const TMHaveTransactions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMHaveTransactions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){from._impl_.hashes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactions)
}

inline void TMHaveTransactions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TMHaveTransactions::~TMHaveTransactions() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMHaveTransactions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hashes_.~RepeatedPtrField();
}

void TMHaveTransactions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMHaveTransactions::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hashes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMHaveTransactions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMHaveTransactions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes hashes = 1;
  for (int i = 0, n = this->_internal_hashes_size(); i < n; i++) {
    const auto& s = this->_internal_hashes(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactions)
  return target;
}

size_t TMHaveTransactions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hashes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hashes_.size());
  for (int i = 0, n = _impl_.hashes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.hashes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMHaveTransactions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMHaveTransactions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMHaveTransactions::GetClassData() const { return &_class_data_; }


void TMHaveTransactions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMHaveTransactions*>(&to_msg);
  auto& from = static_cast<const TMHaveTransactions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hashes_.MergeFrom(from._impl_.hashes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMHaveTransactions::CopyFrom(const TMHaveTransactions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactions::IsInitialized() const {
  return true;
}

void TMHaveTransactions::InternalSwap(TMHaveTransactions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hashes_.InternalSwap(&other->_impl_.hashes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMHaveTransactions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_getter, &descriptor_table_src_2fripple_2fproto_2fripple_2eproto_once,
      file_level_metadata_src_2fripple_2fproto_2fripple_2eproto[34]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protocol::TMManifest*
Arena::CreateMaybeMessage< ::protocol::TMManifest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMManifest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMManifests*
Arena::CreateMaybeMessage< ::protocol::TMManifests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMManifests >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMClusterNode*
Arena::CreateMaybeMessage< ::protocol::TMClusterNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMClusterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLoadSource*
Arena::CreateMaybeMessage< ::protocol::TMLoadSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLoadSource >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMCluster*
Arena::CreateMaybeMessage< ::protocol::TMCluster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLink*
Arena::CreateMaybeMessage< ::protocol::TMLink >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLink >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetPeerShardInfo*
Arena::CreateMaybeMessage< ::protocol::TMGetPeerShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfo*
Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPublicKey*
Arena::CreateMaybeMessage< ::protocol::TMPublicKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetPeerShardInfoV2*
Arena::CreateMaybeMessage< ::protocol::TMGetPeerShardInfoV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetPeerShardInfoV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfoV2_TMIncomplete*
Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfoV2_TMIncomplete >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfoV2_TMIncomplete >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfoV2*
Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfoV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfoV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMTransaction*
Arena::CreateMaybeMessage< ::protocol::TMTransaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMTransactions*
Arena::CreateMaybeMessage< ::protocol::TMTransactions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMTransactions >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMStatusChange*
Arena::CreateMaybeMessage< ::protocol::TMStatusChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMStatusChange >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProposeSet*
Arena::CreateMaybeMessage< ::protocol::TMProposeSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProposeSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMHaveTransactionSet*
Arena::CreateMaybeMessage< ::protocol::TMHaveTransactionSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMHaveTransactionSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorList*
Arena::CreateMaybeMessage< ::protocol::TMValidatorList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidatorList >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::ValidatorBlobInfo*
Arena::CreateMaybeMessage< ::protocol::ValidatorBlobInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::ValidatorBlobInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorListCollection*
Arena::CreateMaybeMessage< ::protocol::TMValidatorListCollection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidatorListCollection >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidation*
Arena::CreateMaybeMessage< ::protocol::TMValidation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidation >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints_TMEndpointv2*
Arena::CreateMaybeMessage< ::protocol::TMEndpoints_TMEndpointv2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoints_TMEndpointv2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints*
Arena::CreateMaybeMessage< ::protocol::TMEndpoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMIndexedObject*
Arena::CreateMaybeMessage< ::protocol::TMIndexedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMIndexedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetObjectByHash*
Arena::CreateMaybeMessage< ::protocol::TMGetObjectByHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetObjectByHash >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerNode*
Arena::CreateMaybeMessage< ::protocol::TMLedgerNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLedgerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetLedger*
Arena::CreateMaybeMessage< ::protocol::TMGetLedger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetLedger >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerData*
Arena::CreateMaybeMessage< ::protocol::TMLedgerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLedgerData >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPing*
Arena::CreateMaybeMessage< ::protocol::TMPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPing >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMSquelch*
Arena::CreateMaybeMessage< ::protocol::TMSquelch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMSquelch >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProofPathRequest*
Arena::CreateMaybeMessage< ::protocol::TMProofPathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProofPathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProofPathResponse*
Arena::CreateMaybeMessage< ::protocol::TMProofPathResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProofPathResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMReplayDeltaRequest*
Arena::CreateMaybeMessage< ::protocol::TMReplayDeltaRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMReplayDeltaRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMReplayDeltaResponse*
Arena::CreateMaybeMessage< ::protocol::TMReplayDeltaResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMReplayDeltaResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMHaveTransactions*
Arena::CreateMaybeMessage< ::protocol::TMHaveTransactions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMHaveTransactions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
